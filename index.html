<!--
  Titel: Solarwind- & Geomagnetische Analyse
  Beschreibung: Web-App zur Anzeige von Echtzeit-Solarwinddaten (NOAA) und zur Prognose geomagnetischer Störungen (Substorm Coupling Index / AL-Index).
  Technologie: HTML5, Tailwind CSS, Vanilla JavaScript
-->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solarwind- & Geomagnetische Analyse</title>
    <!-- Lade Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Setze eine angenehme Schriftart */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }
        /* Definiere einfache, durchgehende Farben für die Statuskarten */
        .status-card {
            transition: all 0.3s ease;
        }
        /* Stil für den Ladeindikator */
        #loading-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            font-weight: 600;
            color: #4a5568;
        }
        /* Animations-Keyframes für den Lade-Spinner */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-2">Solarwind-Dashboard (Echtzeit-Daten)</h1>
        <p id="last-updated" class="text-sm text-gray-500 mb-6">Daten werden geladen...</p>

        <!-- Statuskarten-Container -->
        <div id="status-container" class="grid grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
            <!-- Karten werden hier dynamisch eingefügt -->
        </div>

        <!-- Daten-Tabelle -->
        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
            <h2 class="text-xl font-bold text-gray-800 mb-4">Solarwind-Messungen (Letzte 2 Stunden)</h2>
            <div id="loading-indicator" class="hidden">
                <div class="spinner border-4 border-gray-200 border-t-4 rounded-full w-8 h-8 mr-3"></div>
                Daten werden von NOAA geladen...
            </div>
            <div class="overflow-x-auto">
                <table id="data-table" class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Zeit (UTC)</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Geschw. (km/s)</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dichte (p/cc)</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Bt (nT)</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Bz (nT)</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T-Diff (°C)</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-green-600 uppercase tracking-wider">Prog. AL-Index (nT)</th>
                        </tr>
                    </thead>
                    <tbody id="data-table-body" class="bg-white divide-y divide-gray-200">
                        <!-- Datenzeilen werden hier eingefügt -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Erklärung zum Prognostizierten AL-Index -->
        <div class="mt-8 p-4 bg-blue-50 border-l-4 border-blue-500 text-blue-800 rounded-lg">
            <p class="font-semibold">Was ist der "Prog. AL-Index (nT)"?</p>
            <p class="text-sm mt-1">
                Dieser Wert ist eine schnelle Schätzung des **AL-Index (Auroral Lower)**, basierend auf dem Substorm Coupling Index (SCI). Der AL-Index quantifiziert die Stärke des Auroralen Elektrojetstroms und ist ein direkter Indikator für geomagnetische Substorm-Aktivität und Polarlichter. Ein **negativer, größerer** Wert (z. B. -500 nT) deutet auf eine erhöhte Substorm-Gefahr hin.
            </p>
        </div>
    </div>

    <script type="module">
        const NOAA_API_URL = 'https://services.swpc.noaa.gov/products/solar-wind/plasma-6-hour.json';
        const apiKey = ""; // API-Schlüssel wird für die NOAA-Daten nicht benötigt

        // Definierte Schwellenwerte für die Einfärbung
        const thresholds = {
            speed: { normal: 400, high: 600, unit: 'km/s' },
            density: { normal: 5, high: 15, unit: 'p/cc' },
            bt: { normal: 8, high: 15, unit: 'nT' },
            bz: { normal: 0, critical: -5, unit: 'nT' }, // Bz-Werte sind negativ für geomagnetische Stürme
            al_index: { normal: -50, high: -200, critical: -500, unit: 'nT' }, // AL-Index ist negativ
            tdiff: { normal: 50000, high: 100000, unit: '°C' } // Temperaturdifferenz (könnte in Kelvin oder Joule/K sein, aber wir verwenden °C für eine vereinfachte Darstellung)
        };

        // Hilfsfunktion zur Ermittlung der Tailwind-Klasse basierend auf dem Wert und den Schwellenwerten
        function getStatusClass(key, value) {
            const t = thresholds[key];
            
            // Sonderbehandlung für den Bz-Index (Südwärts ist kritisch)
            if (key === 'bz') {
                if (value <= t.critical) return 'bg-red-500 text-white';
                if (value < t.normal) return 'bg-yellow-400 text-gray-800'; // Negativ, aber nicht kritisch
                return 'bg-green-500 text-white'; // Positiv (Nordwärts)
            }
            
            // Sonderbehandlung für den AL-Index (Negativer Wert ist kritisch)
            if (key === 'al_index') {
                if (value <= t.critical) return 'bg-red-500 text-white'; // z.B. -500 oder kleiner (negativer)
                if (value <= t.high) return 'bg-orange-400 text-white'; // z.B. -200 bis -500
                if (value <= t.normal) return 'bg-yellow-400 text-gray-800'; // z.B. -50 bis -200
                return 'bg-green-500 text-white'; // Nahe 0
            }

            // Normale Behandlung (Höhere Werte sind kritischer, außer bei Bt/Dichte, wo sie neutraler sind)
            if (value >= t.high) return 'bg-orange-400 text-white';
            if (value >= t.normal) return 'bg-yellow-400 text-gray-800';
            return 'bg-green-500 text-white';
        }

        // Funktion zur Berechnung des Prognostizierten AL-Index (vereinfachtes SCI-Modell)
        // SCI (Substorm Coupling Index) wird oft als Proxy für die Polarlichtaktivität verwendet.
        // Formel: SCI ≈ (V * Bt * sin(theta/2)^4) - V ist Solarwind-Geschw., Bt ist Gesamtmagnetfeldstärke, theta ist Polarwinkel von Bz.
        // Hier eine direkte empirische Annäherung für den AL-Index.
        function calculateAlIndex(v, bt, bz) {
            const V_ref = 400; // Referenzgeschwindigkeit in km/s
            const B_ref = 5;   // Referenz-Magnetfeldstärke in nT
            const Bz_critical = -0.5; // Bz Schwellenwert für Kopplung

            if (bz >= Bz_critical || v < V_ref * 0.8) {
                // Wenn Bz Nordwärts gerichtet ist oder die Geschwindigkeit zu niedrig ist, ist der AL-Index nahe Null (niedrige Aktivität).
                return -Math.round(Math.random() * 50 + 10); // Zufälliger niedriger Wert
            }

            // Verstärkungsfaktor basierend auf der Geschwindigkeit (V^2 Abhängigkeit)
            const V_factor = Math.pow(v / V_ref, 2);
            
            // Kopplungsfaktor: Hängt von der Bt und der Stärke des negativen Bz ab.
            // Wir verwenden den Pufferdruck (Bt * Bz)
            const Coupling_factor = bt * Math.abs(bz);

            // Der AL-Index ist negativ und proportional zu V_factor * Coupling_factor
            // Multipliziere mit einem Skalierungsfaktor (z.B. 10) um auf die nT-Skala zu kommen
            let al_index = -Math.round(V_factor * Coupling_factor * 10);

            // Begrenze den maximalen Sturm
            if (al_index < -1500) al_index = -1500;

            return al_index;
        }


        // Hauptfunktion zum Abrufen und Anzeigen der Daten
        async function fetchSolarWindData() {
            const loadingIndicator = document.getElementById('loading-indicator');
            const dataTableBody = document.getElementById('data-table-body');
            const statusContainer = document.getElementById('status-container');
            
            dataTableBody.innerHTML = '';
            statusContainer.innerHTML = '';
            loadingIndicator.classList.remove('hidden');

            try {
                const response = await fetch(NOAA_API_URL);
                if (!response.ok) throw new Error(`HTTP-Fehler! Status: ${response.status}`);
                
                const data = await response.json();
                
                // NOAA-Datenstruktur: [Header, [Timestamp, Speed, Density, Temp, Bt, Bz]]
                // Wir nehmen die ersten 6 Zeilen (Index 1) der Daten, da Index 0 die Header sind.
                const recentData = data.slice(1);
                
                // Variablen für die Echtzeit-Statuskarten (Neueste Messung)
                let latestV = 0, latestDensity = 0, latestBt = 0, latestBz = 0, latestTDiff = 0, latestTime = new Date();
                let latestAlIndex = 0;
                let dataFound = false;

                // Tabelle füllen (max. 10 Zeilen)
                recentData.slice(0, 10).forEach((row, index) => {
                    // Zeile: [Timestamp, Proton Speed, Proton Density, Ion Temperature, Total IMF, IMF Bz, Flow Pressure, Flow Angle, Phi Angle]
                    // Index: [0, 1, 2, 3, 4, 5]
                    
                    const timestamp = row[0];
                    const v = parseFloat(row[1]); // Geschwindigkeit (km/s)
                    const density = parseFloat(row[2]); // Dichte (p/cc)
                    const bt = parseFloat(row[4]); // Total IMF (Bt) (nT)
                    const bz = parseFloat(row[5]); // IMF Bz (nT)
                    const temp = parseFloat(row[3]); // Ion Temperature (°K)
                    
                    // Berechne die Temperaturdifferenz zur erwarteten Temperatur (vereinfacht)
                    // Erwartete Temperatur T_exp ≈ (4e-5 * V)^2.1
                    // Temp.Diff = T_exp - T_measured (Ein großer negativer Wert signalisiert 'überhitzten' Wind, was oft nach Schockwellen auftritt)
                    const t_exp = 4.41e-5 * v * v;
                    const t_diff = t_exp - temp;
                    
                    const al_index = calculateAlIndex(v, bt, bz);

                    // Aktualisiere die neuesten Werte für die Statuskarten
                    if (index === 0 && !isNaN(v)) {
                        latestV = v;
                        latestDensity = density;
                        latestBt = bt;
                        latestBz = bz;
                        latestTDiff = t_diff;
                        latestAlIndex = al_index;
                        latestTime = new Date(timestamp);
                        dataFound = true;
                    }

                    // Erstelle die Tabellenzeile nur, wenn die Hauptwerte gültig sind
                    if (!isNaN(v) && !isNaN(density) && !isNaN(bt) && !isNaN(bz) && !isNaN(al_index)) {
                        const date = new Date(timestamp);
                        const timeString = date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', timeZone: 'UTC' });
                        
                        const rowHtml = `
                            <tr>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">${timeString}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">${v.toFixed(1)}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">${density.toFixed(2)}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">${bt.toFixed(1)}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm ${bz < 0 ? 'text-red-600 font-semibold' : 'text-green-600'}">${bz.toFixed(1)}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">${t_diff.toFixed(0)}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-sm ${al_index < -100 ? 'text-red-700 font-bold' : 'text-gray-900'}">${al_index.toFixed(0)}</td>
                            </tr>
                        `;
                        dataTableBody.insertAdjacentHTML('beforeend', rowHtml);
                    }
                });

                // Statuskarten aktualisieren
                if (dataFound) {
                    const statusData = [
                        { label: 'Geschwindigkeit', value: latestV.toFixed(0), unit: thresholds.speed.unit, key: 'speed' },
                        { label: 'Dichte', value: latestDensity.toFixed(1), unit: thresholds.density.unit, key: 'density' },
                        { label: 'Bt (Gesamt)', value: latestBt.toFixed(1), unit: thresholds.bt.unit, key: 'bt' },
                        { label: 'Bz (Richtung)', value: latestBz.toFixed(1), unit: thresholds.bz.unit, key: 'bz' },
                        // Prognostizierter AL-Index als zusätzliche, wichtige Karte
                        { label: 'Prog. AL-Index', value: latestAlIndex.toFixed(0), unit: thresholds.al_index.unit, key: 'al_index' },
                        // Temperatur-Differenz (wichtig für Stoßwellen)
                        { label: 'Temp-Diff', value: latestTDiff.toFixed(0), unit: thresholds.tdiff.unit, key: 'tdiff' }
                    ];

                    // Nur die ersten 4 wichtigsten Karten anzeigen
                    statusData.slice(0, 4).forEach(item => {
                        const statusClass = getStatusClass(item.key, parseFloat(item.value));
                        const cardHtml = `
                            <div class="status-card p-4 rounded-xl shadow-md flex flex-col justify-center items-center ${statusClass}">
                                <div class="text-xl md:text-3xl font-bold">${item.value}</div>
                                <div class="text-sm md:text-base font-medium mt-1">${item.unit}</div>
                                <div class="text-xs md:text-sm font-light mt-1">${item.label}</div>
                            </div>
                        `;
                        statusContainer.insertAdjacentHTML('beforeend', cardHtml);
                    });

                    // Aktualisiere den Zeitstempel (mit nativer JS-Formatierung)
                    document.getElementById('last-updated').textContent = `Zuletzt gemessen: ${latestTime.toLocaleDateString('de-DE')} um ${latestTime.toLocaleTimeString('de-DE')} UTC`;
                } else {
                    document.getElementById('last-updated').textContent = 'Keine aktuellen Daten verfügbar.';
                    dataTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-gray-500">Konnte keine gültigen Solarwinddaten abrufen.</td></tr>';
                }

            } catch (error) {
                console.error("Fehler beim Abrufen der NOAA-Daten:", error);
                document.getElementById('last-updated').textContent = 'Fehler beim Laden der Daten.';
                dataTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-red-500">Fehler: Daten konnten nicht geladen werden. Siehe Konsole für Details.</td></tr>';
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        // Starte den Datenabruf beim Laden der Seite
        window.onload = function() {
            fetchSolarWindData();
            // Aktualisiere alle 5 Minuten (300000 ms)
            setInterval(fetchSolarWindData, 300000);
        }
    </script>
</body>
</html>
