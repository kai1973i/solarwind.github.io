<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solarwind-Plasma-Daten und Substurm-Kopplungsindex</title>
    <!-- Tailwind CSS laden -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Spezifische Schriftart */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dunkler Hintergrund */
            color: #c9d1d9; /* Heller Text */
        }
        .header-cell {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .header-cell:hover {
            background-color: #21262d;
        }
        .loading-animation {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #58a6ff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* HIGHTLIGHT-KLASSE: Markiert Daten, deren Ankunft theoretisch bereits erfolgt ist */
        .highlight-row {
            background-color: #1a222e; /* Dunkler, dezenter Blauton */
            border-left: 4px solid #3b82f6; /* Subtiler blauer Rand */
        }
        .highlight-row:hover {
            background-color: #242c38 !important;
        }
        .substorm-watch-high {
            background-color: #450a0a !important; /* Dunkelrot */
            border-left: 4px solid #ef4444 !important;
            font-weight: bold;
        }
        .substorm-watch-elevated {
            background-color: #422006 !important; /* Dunkelorange */
            border-left: 4px solid #f97316 !important;
        }
        .status-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
        }
        .status-metric {
            background-color: #161b22;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #30363d;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        .metric-value {
            font-size: 1.875rem; /* text-3xl */
            font-weight: 800; /* font-extrabold */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-extrabold mb-2 text-blue-400">
            Solarwind-Plasma-Daten (L1-Punkt)
        </h1>
        <p class="text-lg mb-6 text-gray-400">
            Daten der NOAA SWPC (Plasma und Magnetfeld) mit berechneter gesch√§tzter Ankunftszeit und Substurm-Kopplungsindex.
        </p>

        <!-- Echtzeit-Statuskarte (Zeigt die Auswirkung des L1-Pakets) -->
        <div id="current-status-card" class="mb-8 status-card-grid">
            <div class="status-metric">
                <p class="text-sm uppercase text-gray-400">Neuster Messwert (L1)</p>
                <p id="latest-time-tag" class="metric-value text-gray-300">-</p>
            </div>
            <div class="status-metric">
                <p class="text-sm uppercase text-gray-400">Gesch. Ankunft (Erde)</p>
                <p id="arrival-time-status" class="metric-value text-blue-400">-</p>
            </div>
            <div class="status-metric">
                <p class="text-sm uppercase text-gray-400">Prog. AL-Index (nT)</p>
                <p id="al-index-status" class="metric-value text-gray-300">-</p>
            </div>
            <div class="status-metric">
                <p class="text-sm uppercase text-gray-400">Substurm-Risiko (SCI)</p>
                <p id="sci-risk-status" class="metric-value text-gray-300">-</p>
            </div>
        </div>
        
        <!-- Status- und Ladeanzeige -->
        <div id="status-message" class="text-center p-4 my-4 bg-gray-800 rounded-lg shadow-lg hidden"></div>
        <div id="loading-indicator" class="flex justify-center items-center p-8">
            <div class="loading-animation"></div>
            <span class="ml-4 text-xl text-blue-400">Daten werden geladen...</span>
        </div>

        <!-- Tabelle f√ºr die Daten -->
        <div id="data-container" class="overflow-x-auto">
            <table id="plasma-table" class="min-w-full bg-gray-800 rounded-lg shadow-2xl hidden">
                <thead>
                    <tr class="bg-blue-600/80 text-white uppercase text-sm leading-normal">
                        <!-- Plasmadaten & Zeiten -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="time_tag">
                            Messzeitpunkt (L1)
                            <span data-sort-icon="time_tag" class="ml-1">‚Üì</span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="speed">
                            Geschw. (km/s)
                            <span data-sort-icon="speed" class="ml-1"></span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="density">
                            Dichte (p/cm¬≥)
                            <span data-sort-icon="density" class="ml-1"></span>
                        </th>
                        <!-- Dynamischer Druck -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="dynamic_pressure_npa">
                            Dyn. Druck (nPa)
                            <span data-sort-icon="dynamic_pressure_npa" class="ml-1"></span>
                        </th>
                        <!-- Magnetfelddaten -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="total_bt">
                            Total Bt (nT)
                            <span data-sort-icon="total_bt" class="ml-1"></span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="bz_nt">
                            Bz (nT)
                            <span data-sort-icon="bz_nt" class="ml-1"></span>
                        </th>
                         <!-- Prog. AL-Index NEUE SPALTE -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="prog_al_index">
                            Prog. AL-Index (nT)
                            <span data-sort-icon="prog_al_index" class="ml-1"></span>
                        </th>
                        <!-- SCI -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="substorm_coupling_index">
                            ‚ö° SCI (V¬∑Bs)
                            <span data-sort-icon="substorm_coupling_index" class="ml-1"></span>
                        </th>
                        <!-- Gesch√§tzte Sturmbeginn-Zeit -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="estimated_onset_time">
                            Gesch. Sturmbeginn (UTC)
                            <span data-sort-icon="estimated_onset_time" class="ml-1"></span>
                        </th>
                        <!-- Substurm-Risiko -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="sci_risk_level">
                            Risiko-Level
                            <span data-sort-icon="sci_risk_level" class="ml-1"></span>
                        </th>
                        <!-- Ankunftszeit -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="arrival_time">
                            Gesch. Ankunftszeit (Erde)
                            <span data-sort-icon="arrival_time" class="ml-1"></span>
                        </th>
                    </tr>
                </thead>
                <tbody id="table-body" class="text-gray-300 text-sm font-light">
                    <!-- Daten werden hier durch JavaScript eingef√ºgt -->
                </tbody>
            </table>
        </div>

        <p class="mt-6 text-xs text-gray-500">
            <span class="font-bold text-blue-400">Hervorgehobene Zeilen</span> (blaue Markierung) sind bereits auf der Erde **angekommen**.<br>
            <span class="font-bold text-pink-400">Prog. AL-Index (nT)</span>: **Prognostizierter Auroral Lower Index.** Dieser Index quantifiziert die St√§rke des Auroralen Elektrojets. Ein **negativer, gr√∂√üerer** Wert (z. B. $<-500\text{ nT}$) deutet auf eine **hohe Substorm-Aktivit√§t** hin. <br>
            <span class="font-bold text-blue-300">üîú</span> in der Ankunftszeit: Der Solarwind wird **innerhalb der n√§chsten 30 Minuten** erwartet.<br>
            <span class="font-bold text-pink-400">üèéÔ∏è √úBERHOLT!</span>: Ein sp√§ter gemessener Plasmaabschnitt wird **fr√ºher** erwartet, was auf eine **Geschwindigkeitsfront** hindeutet.<br>
            <span class="font-bold text-yellow-300">Total Bt (nT)</span>: Der **Gesamtwert** des Magnetfelds. Werte **√ºber $15\text{ nT}$** sind hoch (oft assoziiert mit Sto√üwellen).
            <br><span class="font-bold text-red-400">‚¨áÔ∏è Bz</span>: Zeigt die **S√ºdrichtung** des Magnetfelds an, ein kritischer Indikator f√ºr geomagnetische Aktivit√§t und Subst√ºrme. **(Dies ist die wichtigste Information, die einem Boden-Magnetometer-Index vorausgeht)**<br>
            <span class="font-bold text-yellow-300">üí• STAU! Dyn. Druck</span>: Zeigt eine **starke Kompressionszone (SIR/Sto√üwelle)** an (Dichte > $15\text{ p/cm}^3$ und Druck > $5\text{ nPa}$).<br>
            <span class="font-bold text-red-400">Dyn. Druck (nPa)</span>: Werte **√ºber $10\text{ nPa}$** sind stark erh√∂ht und deuten auf eine erhebliche Magnetosph√§ren-Kompression hin.<br>
            <span class="font-bold text-red-400">üö® SCI (V¬∑Bs)</span>: Hohe Werte (**> 3500**) signalisieren ein **hohes Potenzial f√ºr Subst√ºrme** (starke Polarlichter).
            <br><span class="font-bold text-red-300">‚ö†Ô∏è Gesch. Sturmbeginn</span>: Die **gesch√§tzte fr√ºheste Zeit** f√ºr den **Beginn des geomagnetischen Sturms** (Ankunft + Aufbauzeit).
            <br>Hinweis: Die Daten werden vom NOAA Space Weather Prediction Center (SWPC) bereitgestellt und am L1-Punkt gemessen. Die Tabelle wird jede Minute automatisch aktualisiert.
        </p>
    </div>

    <script type="module">
        // --- Anwendungskonstanten ---
        const PLASMA_API_URL = 'https://services.swpc.noaa.gov/products/solar-wind/plasma-1-day.json';
        const MAG_API_URL = 'https://services.swpc.noaa.gov/products/solar-wind/mag-1-day.json';
        
        const L1_DISTANCE_KM = 1500000;
        const MS_PER_SEC = 1000;
        const TWO_HOURS_MS = 2 * 60 * 60 * 1000;
        const THIRTY_MINUTES_MS = 30 * 60 * 1000;
        const REFRESH_INTERVAL_MS = 60 * 1000;
        
        // Konstante f√ºr die Berechnung des Dynamischen Drucks in nPa
        const DYNAMIC_PRESSURE_FACTOR = 0.001672;
        const CRITICAL_PRESSURE_NPA = 10.0;
        const CRITICAL_DENSITY = 15.0;

        // KONSTANTEN F√úR SUBSTORM COUPLING INDEX (SCI)
        const SCI_WATCH_LOW = 1000; 
        const SCI_WATCH_ELEVATED = 2000; 
        const SCI_WATCH_HIGH = 3500; 
        
        // KONSTANTEN F√úR KRITISCHE AUFBAUZEIT (WERTE WERDEN IM CODE NOCH VERWENDET)
        const SCI_DURATION_HIGH_H = 1.75; 
        const SCI_DURATION_ELEVATED_H = 2.5;
        const SCI_DURATION_MEDIUM_H = 3.0;
        const SCI_DURATION_LOW_H = 100.0; 
        const CRITICAL_BT = 15.0; 
        
        // Konstanten f√ºr AL-Index-Bewertung
        const AL_INDEX_CRITICAL_NT = -500;
        const AL_INDEX_ELEVATED_NT = -200;


        // --- DOM-Elemente ---
        const tableBody = document.getElementById('table-body');
        const plasmaTable = document.getElementById('plasma-table');
        const loadingIndicator = document.getElementById('loading-indicator');
        const statusMessage = document.getElementById('status-message');
        const headers = document.querySelectorAll('.header-cell');

        // Statuskarten-Elemente
        const latestTimeTagEl = document.getElementById('latest-time-tag');
        const arrivalTimeStatusEl = document.getElementById('arrival-time-status');
        const alIndexStatusEl = document.getElementById('al-index-status'); // NEU: AL-Index Status
        const sciRiskStatusEl = document.getElementById('sci-risk-status');


        let allData = [];
        let sortColumn = 'time_tag';
        let sortDirection = 'desc';

        // =========================================================================
        // === Allgemeine Hilfsfunktionen ===
        // =========================================================================
        
        /**
         * Gibt das qualitative Substurm-Risiko basierend auf dem SCI zur√ºck.
         */
        const getSciRiskLevel = (sci) => {
            if (typeof sci !== 'number' || sci < 0) return 'N/A';
            if (sci >= SCI_WATCH_HIGH) return 'üö® HOCH (> 3500)';
            if (sci >= SCI_WATCH_ELEVATED) return '‚ö†Ô∏è Erh√∂ht (> 2000)';
            if (sci >= SCI_WATCH_LOW) return 'Mittel (> 1000)';
            return 'Gering';
        };

        /**
         * Liefert die kritische Dauer in Stunden (als Zahl) basierend auf dem SCI-Wert.
         * Diese Funktion wird weiterhin ben√∂tigt, um die "Gesch. Sturmbeginn"-Zeit zu berechnen.
         */
        const getRequiredBuildupDuration = (sci) => {
            if (typeof sci !== 'number' || sci < SCI_WATCH_LOW) return SCI_DURATION_LOW_H; 
            if (sci >= SCI_WATCH_HIGH) return SCI_DURATION_HIGH_H;
            if (sci >= SCI_WATCH_ELEVATED) return SCI_DURATION_ELEVATED_H;
            return SCI_DURATION_MEDIUM_H; 
        };

        /**
         * Konvertiert den NOAA-Zeitstempel-String in ein UTC-Date-Objekt
         */
        const parseUtcTimeTag = (timeTag) => {
            return new Date(timeTag.replace(' ', 'T') + 'Z');
        };

        /**
         * Formatiert Zeitstempel mit Datum und Uhrzeit
         */
        const formatTime = (date) => {
            if (!(date instanceof Date) || isNaN(date)) return 'N/A';
            const options = {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hour12: false,
                timeZone: 'UTC'
            };
            return date.toLocaleString('de-DE', options) + ' UTC';
        };

        /**
         * NEU: Berechnung des Prognostizierten AL-Index (Auroral Lower Index)
         * Vereinfachtes Modell basierend auf SCI und Bz/Bt-Verh√§ltnissen.
         */
        const calculateProgALIndex = (sci, totalBt, bz) => {
            if (typeof sci !== 'number' || isNaN(sci) || sci <= 0 || typeof totalBt !== 'number' || isNaN(totalBt) || typeof bz !== 'number' || isNaN(bz)) {
                return 'N/A';
            }

            // Der AL-Index ist negativ (quantifiziert den auroralen Elektrojet, der nach Westen flie√üt).
            // Er ist proportional zur SCI-Energieeinspeisung.
            
            // Koeffizient, der die SCI-Energie in den AL-Index umrechnet (empirisch)
            const conversionFactor = 0.2; 
            
            // Multipliziere SCI mit dem Faktor
            let alIndex = -sci * conversionFactor;

            // F√ºhre eine zus√§tzliche Korrektur ein, wenn das Bz sehr stark S√ºdw√§rts ist
            if (bz < -10) {
                 alIndex *= 1.2; // 20% Verst√§rkung bei extrem starker S√ºdw√§rts-Kopplung
            } else if (totalBt > 20) {
                 alIndex *= 1.1; // 10% Verst√§rkung bei sehr hohem Bt (Sto√üwelle)
            }
            
            // Der AL-Index kann nicht beliebig klein werden (realistische Obergrenze)
            if (alIndex < -3000) alIndex = -3000;
            
            // Runde auf ganze Zahlen f√ºr die Anzeige
            return Math.round(alIndex);
        }

        /**
         * F√ºhrt die Berechnung der gesch√§tzten Ankunftszeit, des Dynamischen Drucks, 
         * des SCI und der gesch√§tzten Sturmbeginn-Zeit durch
         */
        const calculateArrival = (entry) => {
            const speed = parseFloat(entry.speed);
            const density = parseFloat(entry.density);
            const bx = parseFloat(entry.bx_nt);
            const by = parseFloat(entry.by_nt);
            const bz = parseFloat(entry.bz_nt);
            const timeTag = entry.time_tag;

            // 1. Berechnung des Magnetischen Totalwerts (Bt)
            let totalBt = 'N/A';
            if (!isNaN(bx) && !isNaN(by) && !isNaN(bz)) {
                totalBt = Math.sqrt(bx*bx + by*by + bz*bz);
            } else if (entry.bt_nt && entry.bt_nt !== 'N/A') {
                 totalBt = parseFloat(entry.bt_nt);
            }

            // 2. Berechnung des Dynamischen Drucks (nPa)
            let dynamicPressure = 'N/A';
            if (!isNaN(speed) && speed > 0 && !isNaN(density) && density >= 0) {
                dynamicPressure = DYNAMIC_PRESSURE_FACTOR * density * (speed * speed);
            }
            
            // 3. Berechnung des Substorm Coupling Index (SCI)
            let sci = 'N/A';
            if (!isNaN(speed) && speed > 0 && !isNaN(bz)) {
                // SCI (V_sw * B_s)
                sci = speed * Math.max(0, -bz);
            }

            // 4. Berechnung des Prognostizierten AL-Index (NEU)
            const progAlIndex = calculateProgALIndex(sci, totalBt, bz);

            // 5. Qualitative Risikobewertung
            const sciRiskLevel = getSciRiskLevel(sci);

            // 6. Kritische Aufbauzeit (wird f√ºr Sturmbeginn ben√∂tigt)
            const criticalBuildupDuration = getRequiredBuildupDuration(sci);
            
            // 7. Berechnung der Ankunftszeit
            let travelTimeHours = 'N/A';
            let travelTimeMinutes = 'N/A';
            let travelTimeMs = null;
            let arrivalDate = 'Ung√ºltige Geschw.';
            let estimatedOnset = 'N/A';

            if (!isNaN(speed) && speed > 0 && speed <= 10000) {
                const travelTimeSeconds = L1_DISTANCE_KM / speed;
                travelTimeHours = travelTimeSeconds / 3600;
                travelTimeMinutes = travelTimeSeconds / 60;
                travelTimeMs = travelTimeSeconds * MS_PER_SEC;
                const measurementDate = parseUtcTimeTag(timeTag);
                arrivalDate = new Date(measurementDate.getTime() + travelTimeMs);
            }
            
            // 8. Gesch√§tzte Sturmbeginn-Zeit (Ankunftszeit + Kritische Aufbauzeit)
            if (arrivalDate instanceof Date && !isNaN(arrivalDate) && criticalBuildupDuration !== SCI_DURATION_LOW_H) {
                const durationMs = criticalBuildupDuration * 60 * 60 * 1000;
                estimatedOnset = new Date(arrivalDate.getTime() + durationMs);
            }


            return {
                ...entry,
                dynamic_pressure_npa: dynamicPressure,
                substorm_coupling_index: sci, 
                prog_al_index: progAlIndex, // NEU: Prog. AL-Index
                sci_risk_level: sciRiskLevel, 
                critical_buildup_duration_h: criticalBuildupDuration, // Wird intern behalten
                total_bt: totalBt, 
                travel_time_h: travelTimeHours,
                travel_time_m: travelTimeMinutes, 
                travel_time_ms: travelTimeMs,
                arrival_time: arrivalDate,
                estimated_onset_time: estimatedOnset, 
            };
        };


        // =========================================================================
        // === Statuskarten-Logik ===
        // =========================================================================

        /**
         * Aktualisiert die Statuskarte √ºber der Tabelle mit den aktuellsten Werten.
         */
        const updateStatusCard = (entry) => {
            const nowUtc = new Date();
            
            // 1. Messzeitpunkt
            latestTimeTagEl.textContent = entry.time_tag.substring(11, 16) + ' UTC';

            // 2. Ankunftszeit
            let arrivalText = 'Wird berechnet...';
            let arrivalColor = 'text-gray-300';
            
            if (entry.arrival_time instanceof Date && !isNaN(entry.arrival_time)) {
                const diffMs = entry.arrival_time.getTime() - nowUtc.getTime();
                const arrivalTimeStr = entry.arrival_time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', timeZone: 'UTC' });
                
                if (diffMs <= 0) {
                    arrivalText = `ANGEKOMMEN! ${arrivalTimeStr} UTC`;
                    arrivalColor = 'text-green-500';
                } else if (diffMs <= THIRTY_MINUTES_MS) {
                    arrivalText = `üîú ${arrivalTimeStr} UTC (Bald!)`;
                    arrivalColor = 'text-red-400';
                } else {
                    arrivalText = `${arrivalTimeStr} UTC (${entry.travel_time_h.toFixed(1)} h)`;
                    arrivalColor = 'text-blue-400';
                }
            }
            arrivalTimeStatusEl.textContent = arrivalText;
            arrivalTimeStatusEl.className = `metric-value ${arrivalColor}`;

            // 3. Prog. AL-Index (NEU)
            const alIndex = entry.prog_al_index;
            let alText = String(alIndex);
            let alColor = 'text-gray-300';
            
            if (typeof alIndex === 'number') {
                alText = `${alIndex.toFixed(0)} nT`;
                if (alIndex <= AL_INDEX_CRITICAL_NT) {
                    alColor = 'text-red-400 font-extrabold';
                } else if (alIndex <= AL_INDEX_ELEVATED_NT) {
                    alColor = 'text-orange-300';
                } else {
                    alColor = 'text-green-400';
                }
            }
            alIndexStatusEl.textContent = alText;
            alIndexStatusEl.className = `metric-value ${alColor}`;

            // 4. SCI Risiko
            const sci = entry.substorm_coupling_index;
            let sciText = entry.sci_risk_level;
            let sciColor = 'text-gray-300';

            if (typeof sci === 'number') {
                if (sci > SCI_WATCH_HIGH) {
                    sciColor = 'text-red-400 font-extrabold';
                } else if (sci > SCI_WATCH_ELEVATED) {
                    sciColor = 'text-orange-400 font-bold';
                } else if (sci > SCI_WATCH_LOW) {
                    sciColor = 'text-yellow-400';
                }
                sciText = sciText.replace('üö® HOCH', 'HOCH');
                sciText = sciText.replace('‚ö†Ô∏è Erh√∂ht', 'Erh√∂ht');
            }
            sciRiskStatusEl.textContent = sciText;
            sciRiskStatusEl.className = `metric-value ${sciColor}`;
        };


        // =========================================================================
        // === Tabellen- und UI-Logik ===
        // =========================================================================

        /**
         * Rendert die Daten in die HTML-Tabelle
         */
        const renderTable = (data) => {
            tableBody.innerHTML = '';
            if (data.length === 0) {
                statusMessage.textContent = 'Keine Daten in den letzten 2 Stunden zum Anzeigen vorhanden.';
                statusMessage.classList.remove('hidden', 'bg-red-900', 'bg-green-900/50');
                statusMessage.classList.add('bg-yellow-900', 'text-yellow-400');
                plasmaTable.classList.add('hidden');
                return;
            }
            
            const nowUtc = new Date();

            data.forEach((entry, index) => {
                
                let isArrived = false;
                if (entry.arrival_time instanceof Date && !isNaN(entry.arrival_time)) {
                    if (entry.arrival_time.getTime() <= nowUtc.getTime()) {
                        isArrived = true;
                    }
                }

                let rowClass = index % 2 !== 0 ? 'bg-gray-700/50' : '';
                rowClass += isArrived ? ' highlight-row' : '';

                const row = document.createElement('tr');
                row.className = `border-b border-gray-700 hover:bg-gray-700 transition duration-150 ${rowClass}`;

                // --- Bz (Magnetfeld) Verbesserungen ---
                let bzColor = 'text-gray-300';
                let bzIcon = '';
                const bz = parseFloat(entry.bz_nt);
                if (!isNaN(bz)) {
                    if (bz < -5) { 
                        bzColor = 'text-red-400 font-bold';
                        bzIcon = '‚¨áÔ∏è'; 
                    } else if (bz < 0) {
                        bzColor = 'text-orange-300';
                        bzIcon = '‚Üì'; 
                    } else if (bz > 5) {
                        bzColor = 'text-blue-300';
                        bzIcon = '‚¨ÜÔ∏è'; 
                    } else if (bz > 0) {
                        bzColor = 'text-green-400';
                        bzIcon = '‚Üë'; 
                    }
                }

                // Farben f√ºr die Geschwindigkeit
                let speedColor = 'text-green-400';
                const speed = parseFloat(entry.speed);
                if (speed > 550) {
                    speedColor = 'text-red-400 font-bold';
                } else if (speed > 450) {
                    speedColor = 'text-yellow-400';
                }

                // --- Dyn. Druck Hervorhebung und Kompression ---
                let pressureColor = 'text-gray-300';
                let compressionIcon = '';
                const pressure = entry.dynamic_pressure_npa;
                const density = parseFloat(entry.density);

                if (typeof pressure === 'number') {
                    if (pressure > CRITICAL_PRESSURE_NPA) {
                        pressureColor = 'text-red-400 font-bold'; 
                    } else if (pressure > 5.0) {
                        pressureColor = 'text-orange-400'; 
                    } else if (pressure < 0.5) {
                        pressureColor = 'text-gray-500'; 
                    }
                }

                // Kompressions-Indikator
                if (!isNaN(density) && density >= CRITICAL_DENSITY && typeof pressure === 'number' && pressure > 5.0) {
                    pressureColor = 'text-yellow-300 font-extrabold'; 
                    compressionIcon = 'üí• STAU!'; 
                }

                // --- Total Bt Hervorhebung ---
                let btColor = 'text-gray-300';
                const totalBt = entry.total_bt;
                if (typeof totalBt === 'number' && totalBt > CRITICAL_BT) {
                    btColor = 'text-yellow-300 font-bold';
                } else if (typeof totalBt === 'number' && totalBt < 5.0) {
                    btColor = 'text-gray-500';
                }

                // --- SCI (Substorm Coupling Index) und Reihen-Klassifizierung ---
                const sci = entry.substorm_coupling_index;
                let sciColor = 'text-gray-300';
                
                if (typeof sci === 'number') {
                    if (sci > SCI_WATCH_HIGH) {
                        sciColor = 'text-red-400 font-extrabold';
                        row.classList.add('substorm-watch-high'); 
                    } else if (sci > SCI_WATCH_ELEVATED) {
                        sciColor = 'text-orange-400 font-bold';
                        row.classList.add('substorm-watch-elevated');
                    } else if (sci > SCI_WATCH_LOW) {
                        sciColor = 'text-yellow-400';
                    }
                }
                
                const sciValue = typeof sci === 'number' ? sci.toFixed(0) : String(sci);
                
                // --- Prog. AL-Index Hervorhebung (NEU) ---
                const alIndex = entry.prog_al_index;
                let alIndexColor = 'text-gray-400';
                const alIndexValue = typeof alIndex === 'number' ? alIndex.toFixed(0) : String(alIndex);

                if (typeof alIndex === 'number') {
                    if (alIndex <= AL_INDEX_CRITICAL_NT) {
                        alIndexColor = 'text-red-400 font-extrabold';
                    } else if (alIndex <= AL_INDEX_ELEVATED_NT) {
                        alIndexColor = 'text-orange-400 font-bold';
                    } else if (alIndex < 0) {
                         alIndexColor = 'text-yellow-400';
                    } else {
                        alIndexColor = 'text-green-400';
                    }
                }

                // TABELLENZELLEN HINZUF√úGEN
                row.innerHTML += `<td class="py-3 px-6 text-left">${formatTime(parseUtcTimeTag(entry.time_tag))}</td>`;
                row.innerHTML += `<td class="py-3 px-6 text-left ${speedColor}">${parseFloat(entry.speed).toFixed(1)}</td>`;
                row.innerHTML += `<td class="py-3 px-6 text-left">${parseFloat(entry.density).toFixed(2)}</td>`;
                
                // Dynamischer Druck Zelle
                const pressureValue = typeof pressure === 'number' ? pressure.toFixed(2) : String(pressure);
                row.innerHTML += `<td class="py-3 px-6 text-left ${pressureColor}">
                    ${compressionIcon ? `<span class="mr-1">${compressionIcon}</span>` : ''}${pressureValue}
                </td>`;
                
                // Total Bt Zelle
                const totalBtValue = typeof totalBt === 'number' ? totalBt.toFixed(1) : String(totalBt);
                row.innerHTML += `<td class="py-3 px-6 text-left ${btColor}">${totalBtValue}</td>`;
                
                // Bz (nT)
                row.innerHTML += `<td class="py-3 px-6 text-left ${bzColor}">
                    ${bzIcon ? `<span class="mr-1">${bzIcon}</span>` : ''}${parseFloat(entry.bz_nt).toFixed(1)}
                </td>`;

                // Prog. AL-Index (NEU)
                 row.innerHTML += `<td class="py-3 px-6 text-left ${alIndexColor}">
                    ${alIndexValue}
                </td>`;


                // SCI (Substorm Coupling Index) Zelle
                 row.innerHTML += `<td class="py-3 px-6 text-left ${sciColor}">
                    ${sciValue}
                </td>`;
                
                // Gesch√§tzte Sturmbeginn-Zeit
                let onsetTimeText = 'N/A';
                let onsetTimeColor = 'text-gray-400';
                
                if (entry.estimated_onset_time instanceof Date && !isNaN(entry.estimated_onset_time)) {
                    onsetTimeText = formatTime(entry.estimated_onset_time).substring(11, 20); 
                    const diffMs = entry.estimated_onset_time.getTime() - nowUtc.getTime();

                    if (diffMs > 0 && diffMs <= THIRTY_MINUTES_MS) {
                        onsetTimeColor = 'text-red-300 font-bold';
                        onsetTimeText = `‚ö†Ô∏è SOON! ${onsetTimeText}`;
                    } else if (diffMs <= 0) {
                        onsetTimeColor = 'text-red-400 font-extrabold';
                        onsetTimeText = `‚ö†Ô∏è JETZT! ${onsetTimeText}`;
                    } else {
                        onsetTimeColor = 'text-blue-300';
                    }
                }
                
                row.innerHTML += `<td class="py-3 px-6 text-left ${onsetTimeColor}">${onsetTimeText}</td>`;

                // Substurm-Risiko Zelle
                let riskColor = '';
                if (entry.sci_risk_level.startsWith('üö® HOCH')) {
                    riskColor = 'text-red-400 font-bold';
                } else if (entry.sci_risk_level.startsWith('‚ö†Ô∏è Erh√∂ht')) {
                    riskColor = 'text-orange-400';
                } else if (entry.sci_risk_level.startsWith('Mittel')) {
                    riskColor = 'text-yellow-400';
                } else {
                    riskColor = 'text-gray-400';
                }

                row.innerHTML += `<td class="py-3 px-6 text-left ${riskColor}">
                    ${entry.sci_risk_level}
                </td>`;


                // --- √úberhol-Indikator ---
                let isOvertaking = false;
                if (index < data.length - 1) {
                    const nextEntry = data[index + 1]; 
                    const currentArrival = entry.arrival_time instanceof Date ? entry.arrival_time.getTime() : Infinity;
                    const nextArrival = nextEntry.arrival_time instanceof Date ? nextEntry.arrival_time.getTime() : Infinity;

                    if (currentArrival < nextArrival) {
                        isOvertaking = true;
                    }
                }
                
                // Ankunftszeit
                let arrivalTimeCell = `<td class="py-3 px-6 text-left">`;
                
                if (entry.arrival_time instanceof Date && !isNaN(entry.arrival_time)) {
                    const diffMs = entry.arrival_time.getTime() - nowUtc.getTime();
                    
                    let timeText = entry.arrival_time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: 'UTC' }) + ' UTC';
                    let cellClass = '';

                    if (isOvertaking) {
                        cellClass += ' bg-pink-900/40 border-l border-pink-600';
                        timeText = `<span class="text-pink-400 font-extrabold">üèéÔ∏è √úBERHOLT! ${timeText}</span>`;
                    }
                    
                    else if (diffMs > 0 && diffMs <= THIRTY_MINUTES_MS) {
                        cellClass = 'bg-blue-900/40 border-r border-blue-600';
                        timeText = `<span class="text-blue-300 font-extrabold">üîú ${timeText}</span>`;
                    } 
                    
                    else if (isArrived) {
                        timeText = `<span class="font-bold text-gray-200">${timeText}</span>`;
                    } 
                    
                    else {
                        timeText = `<span class="font-medium">${timeText}</span>`;
                    }

                    arrivalTimeCell = `<td class="py-3 px-6 text-left ${cellClass}">`;
                    arrivalTimeCell += timeText;
                    
                } else {
                    arrivalTimeCell += `<span class="text-red-500">${entry.arrival_time}</span>`;
                }
                arrivalTimeCell += `</td>`;
                row.innerHTML += arrivalTimeCell;
                
                tableBody.appendChild(row);
            });
            plasmaTable.classList.remove('hidden');
        };

        /**
         * Sortiert die Daten basierend auf der ausgew√§hlten Spalte und Richtung
         */
        const sortData = () => {
            const keyMap = {
                'time_tag': d => parseUtcTimeTag(d.time_tag).getTime(),
                'speed': d => parseFloat(d.speed) || -Infinity,
                'density': d => parseFloat(d.density) || -Infinity,
                'dynamic_pressure_npa': d => typeof d.dynamic_pressure_npa === 'number' ? d.dynamic_pressure_npa : -Infinity,
                'total_bt': d => typeof d.total_bt === 'number' ? d.total_bt : -Infinity,
                'bz_nt': d => parseFloat(d.bz_nt) || -Infinity,
                'prog_al_index': d => typeof d.prog_al_index === 'number' ? d.prog_al_index : -Infinity, // NEU: Prog. AL-Index
                'substorm_coupling_index': d => typeof d.substorm_coupling_index === 'number' ? d.substorm_coupling_index : -Infinity,
                'estimated_onset_time': d => d.estimated_onset_time instanceof Date ? d.estimated_onset_time.getTime() : Infinity,
                'sci_risk_level': d => typeof d.substorm_coupling_index === 'number' ? d.substorm_coupling_index : -Infinity, 
                'arrival_time': d => d.travel_time_ms !== null ? parseUtcTimeTag(d.time_tag).getTime() + d.travel_time_ms : -Infinity,
            };

            allData.sort((a, b) => {
                const valA = keyMap[sortColumn](a);
                const valB = keyMap[sortColumn](b);

                let comparison = 0;
                if (valA > valB) {
                    comparison = 1;
                } else if (valA < valB) {
                    comparison = -1;
                }

                // Standardm√§√üig absteigende Sortierung (neueste, gr√∂√üte, kritischste Werte zuerst)
                let finalComparison = comparison * -1; 
                
                // Sonderfall: Zeitspalten (time_tag, arrival_time) -> Absteigend (neueste zuerst) ist Standard
                if (sortColumn === 'time_tag' || sortColumn === 'arrival_time') {
                    finalComparison = sortDirection === 'asc' ? comparison : comparison * -1;
                }

                // Sonderfall: Gesch. Sturmbeginn-Zeit -> Aufsteigend (fr√ºhester Termin zuerst) ist kritischer
                if (sortColumn === 'estimated_onset_time') {
                    finalComparison = comparison; // Aufsteigend (fr√ºhester zuerst)
                }

                // Sonderfall: Bz und Prog. AL-Index -> Negative (kleinste) Werte sind kritischer.
                if (sortColumn === 'bz_nt' || sortColumn === 'prog_al_index') {
                    // Aufsteigend (ASC): Negativste (kritischste) Werte zuerst
                    finalComparison = comparison;
                }
                
                return finalComparison;
            });

            document.querySelectorAll('[data-sort-icon]').forEach(icon => icon.textContent = '');
            const currentIcon = document.querySelector(`[data-sort-icon="${sortColumn}"]`);
            if (currentIcon) {
                // Anzeige der Sortierrichtung
                
                 let displayDirection = '';
                if (sortColumn === 'bz_nt' || sortColumn === 'prog_al_index' || sortColumn === 'estimated_onset_time') {
                    // Diese Spalten sortieren standardm√§√üig kritische Werte zuerst (Bz/AL negativ, Onset fr√ºh)
                    displayDirection = '‚Üì';
                } else {
                    displayDirection = sortDirection === 'asc' ? '‚Üë' : '‚Üì';
                }
                currentIcon.textContent = displayDirection;
            }
            // Standardm√§√üig nach Zeit absteigend sortieren
            if (sortColumn === 'time_tag') {
                const defaultIcon = document.querySelector(`[data-sort-icon="time_tag"]`);
                defaultIcon.textContent = '‚Üì';
            }

            renderTable(allData);
        };

        /**
         * Holt die Daten von einem NOAA-Endpunkt
         */
        const fetchData = async (url) => {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP-Fehler beim Laden von ${url}: ${response.status}`);
            }
            const rawData = await response.json();
            return rawData.slice(1);
        };


        /**
         * Hauptfunktion zum Abrufen und Verarbeiten der Daten
         */
        const fetchSolarWindData = async () => {
            loadingIndicator.classList.remove('hidden');
            statusMessage.classList.add('hidden');
            plasmaTable.classList.add('hidden');

            try {
                
                const [plasmaDataRaw, magDataRaw] = await Promise.all([
                    fetchData(PLASMA_API_URL),
                    fetchData(MAG_API_URL)
                ]);

                // Indizes f√ºr das Magnetfeld-Array:
                const MAG_TIME_INDEX = 0;
                const MAG_BX_INDEX = 1;
                const MAG_BY_INDEX = 2;
                const MAG_BZ_INDEX = 3;
                const MAG_BT_INDEX = 4;

                const magMap = new Map();
                magDataRaw.forEach(row => {
                    const timeTag = row[MAG_TIME_INDEX];
                    // √úberpr√ºfen auf NOAA-Platzhalter (z.B. "999.9" oder "-9999.9")
                    if (row[MAG_BX_INDEX] !== 'null' && parseFloat(row[MAG_BX_INDEX]) > -900 &&
                        row[MAG_BY_INDEX] !== 'null' && parseFloat(row[MAG_BY_INDEX]) > -900 &&
                        row[MAG_BZ_INDEX] !== 'null' && parseFloat(row[MAG_BZ_INDEX]) > -900) {
                        
                        magMap.set(timeTag, {
                            bx_nt: row[MAG_BX_INDEX],
                            by_nt: row[MAG_BY_INDEX],
                            bz_nt: row[MAG_BZ_INDEX],
                            bt_nt: row[MAG_BT_INDEX] || 'N/A'
                        });
                    }
                });

                const processedData = plasmaDataRaw.map(row => {
                    const timeTag = row[0];
                    const magEntry = magMap.get(timeTag) || { bx_nt: 'N/A', by_nt: 'N/A', bz_nt: 'N/A', bt_nt: 'N/A' };
                    
                    const entry = {
                        time_tag: timeTag,
                        density: row[1],
                        speed: row[2],
                        bx_nt: magEntry.bx_nt, 
                        by_nt: magEntry.by_nt,
                        bz_nt: magEntry.bz_nt,
                        bt_nt: magEntry.bt_nt,
                    };
                    return calculateArrival(entry);
                });

                if (processedData.length > 0) {
                    
                    // Finde den neuesten Eintrag zur Anzeige im Status-Dashboard
                    const sortedByTime = [...processedData].sort((a, b) => 
                        parseUtcTimeTag(b.time_tag).getTime() - parseUtcTimeTag(a.time_tag).getTime()
                    );
                    const latestEntry = sortedByTime.find(e => 
                        parseFloat(e.speed) > 0 && 
                        typeof e.substorm_coupling_index === 'number'
                    );

                    if (latestEntry) {
                        updateStatusCard(latestEntry);
                    }

                    const latestTimeMs = parseUtcTimeTag(sortedByTime[0].time_tag).getTime();
                    const cutoffTimeMs = latestTimeMs - TWO_HOURS_MS;

                    allData = processedData.filter(entry => {
                        const entryTimeMs = parseUtcTimeTag(entry.time_tag).getTime();
                        return entryTimeMs >= cutoffTimeMs;
                    });

                    statusMessage.textContent = `Daten (24h Quellen) erfolgreich geladen. Zeige ${allData.length} Eintr√§ge der letzten 2 Stunden (bis zum letzten Messwert, UTC). N√§chste Aktualisierung in 1 Minute.`;
                    statusMessage.classList.remove('hidden', 'bg-red-900', 'bg-yellow-900');
                    statusMessage.classList.add('bg-green-900/50', 'text-green-400', 'font-semibold');

                } else {
                    allData = [];
                    statusMessage.textContent = 'Daten erfolgreich geladen, aber keine Eintr√§ge in den letzten 2 Stunden gefunden.';
                    statusMessage.classList.remove('hidden', 'bg-red-900', 'bg-green-900/50');
                    statusMessage.classList.add('bg-yellow-900', 'text-yellow-400');
                }

                sortData();

            } catch (error) {
                console.error("Fehler beim Abrufen der Daten:", error);
                statusMessage.textContent = `Fehler beim Laden der Daten: ${error.message}. N√§chste Aktualisierung in 1 Minute.`;
                statusMessage.classList.remove('hidden', 'bg-green-900/50', 'bg-yellow-900');
                statusMessage.classList.add('bg-red-900', 'text-red-400');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        };

        /**
         * Startet den initialen Ladevorgang und richtet den Auto-Refresh-Intervall ein.
         */
        const startApp = () => {
            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.sortKey;
                    if (sortColumn === key) {
                        // Bei Klick auf dieselbe Spalte: Richtung umkehren
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        // Bei Klick auf neue Spalte: Standardrichtung setzen
                        sortColumn = key;
                        
                        // Standard: DESC (Neueste, gr√∂√üte, kritischste Werte zuerst)
                        sortDirection = 'desc'; 
                        
                        // Ausnahmen:
                        // Bz/AL-Index: ASC (negativste Werte zuerst) ist kritischer.
                         if (key === 'bz_nt' || key === 'prog_al_index' || key === 'estimated_onset_time') {
                            sortDirection = 'asc'; 
                        }
                    }
                    sortData();
                });
            });

            fetchSolarWindData();
            setInterval(fetchSolarWindData, REFRESH_INTERVAL_MS);
        };

        window.onload = startApp;
    </script>
</body>
</html>
