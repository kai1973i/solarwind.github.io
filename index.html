<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solarwind-Plasma-Daten und Substurm-Kopplungsindex</title>
    <!-- Tailwind CSS laden -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Spezifische Schriftart */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dunkler Hintergrund */
            color: #c9d1d9; /* Heller Text */
        }
        .header-cell {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .header-cell:hover {
            background-color: #21262d;
        }
        .loading-animation {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #58a6ff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* HIGHTLIGHT-KLASSE: Markiert Daten, deren Ankunft theoretisch bereits erfolgt ist */
        .highlight-row {
            background-color: #1a222e; /* Dunkler, dezenter Blauton */
            border-left: 4px solid #3b82f6; /* Subtiler blauer Rand */
        }
        .highlight-row:hover {
            background-color: #242c38 !important;
        }
        .substorm-watch-high {
            background-color: #450a0a !important; /* Dunkelrot */
            border-left: 4px solid #ef4444 !important;
            font-weight: bold;
        }
        .substorm-watch-elevated {
            background-color: #422006 !important; /* Dunkelorange */
            border-left: 4px solid #f97316 !important;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-extrabold mb-2 text-blue-400">
            Solarwind-Plasma-Daten (L1-Punkt)
        </h1>
        <p class="text-lg mb-6 text-gray-400">
            Daten der NOAA SWPC (Plasma und Magnetfeld) mit berechneter gesch√§tzter Ankunftszeit und Substurm-Kopplungsindex.
        </p>

        <!-- Status- und Ladeanzeige -->
        <div id="status-message" class="text-center p-4 my-4 bg-gray-800 rounded-lg shadow-lg hidden"></div>
        <div id="loading-indicator" class="flex justify-center items-center p-8">
            <div class="loading-animation"></div>
            <span class="ml-4 text-xl text-blue-400">Daten werden geladen...</span>
        </div>

        <!-- Tabelle f√ºr die Daten -->
        <div id="data-container" class="overflow-x-auto">
            <table id="plasma-table" class="min-w-full bg-gray-800 rounded-lg shadow-2xl hidden">
                <thead>
                    <tr class="bg-blue-600/80 text-white uppercase text-sm leading-normal">
                        <!-- Plasmadaten & Zeiten -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="time_tag">
                            Messzeitpunkt (L1)
                            <span data-sort-icon="time_tag" class="ml-1">‚Üì</span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="speed">
                            Geschw. (km/s)
                            <span data-sort-icon="speed" class="ml-1"></span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="density">
                            Dichte (p/cm¬≥)
                            <span data-sort-icon="density" class="ml-1"></span>
                        </th>
                        <!-- Dynamischer Druck -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="dynamic_pressure_npa">
                            Dyn. Druck (nPa)
                            <span data-sort-icon="dynamic_pressure_npa" class="ml-1"></span>
                        </th>
                        <!-- Magnetfelddaten -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="total_bt">
                            Total Bt (nT)
                            <span data-sort-icon="total_bt" class="ml-1"></span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="bz_nt">
                            Bz (nT)
                            <span data-sort-icon="bz_nt" class="ml-1"></span>
                        </th>
                        <!-- SCI -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="substorm_coupling_index">
                            ‚ö° SCI (V¬∑Bs)
                            <span data-sort-icon="substorm_coupling_index" class="ml-1"></span>
                        </th>
                        <!-- Kritische Aufbauzeit -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="critical_buildup_duration_h">
                            Krit. Aufbauzeit (h)
                            <span data-sort-icon="critical_buildup_duration_h" class="ml-1"></span>
                        </th>
                        <!-- Gesch√§tzte Sturmbeginn-Zeit -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="estimated_onset_time">
                            Gesch. Sturmbeginn (UTC)
                            <span data-sort-icon="estimated_onset_time" class="ml-1"></span>
                        </th>
                        <!-- Substurm-Risiko -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="sci_risk_level">
                            Risiko-Level
                            <span data-sort-icon="sci_risk_level" class="ml-1"></span>
                        </th>
                        <!-- Ankunftszeit -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="arrival_time">
                            Gesch. Ankunftszeit (Erde)
                            <span data-sort-icon="arrival_time" class="ml-1"></span>
                        </th>
                         <!-- Laufzeit (Minuten) -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="travel_time_m">
                            Laufzeit (min)
                            <span data-sort-icon="travel_time_m" class="ml-1"></span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="travel_time_h">
                            Laufzeit (h)
                            <span data-sort-icon="travel_time_h" class="ml-1"></span>
                        </th>
                    </tr>
                </thead>
                <tbody id="table-body" class="text-gray-300 text-sm font-light">
                    <!-- Daten werden hier durch JavaScript eingef√ºgt -->
                </tbody>
            </table>
        </div>

        <p class="mt-6 text-xs text-gray-500">
            <span class="font-bold text-blue-400">Hervorgehobene Zeilen</span> (blaue Markierung) sind bereits auf der Erde **angekommen**.<br>
            <span class="font-bold text-blue-300">üîú</span> in der Ankunftszeit: Der Solarwind wird **innerhalb der n√§chsten 30 Minuten** erwartet.<br>
            <span class="font-bold text-pink-400">üèéÔ∏è √úBERHOLT!</span>: Ein sp√§ter gemessener Plasmaabschnitt wird **fr√ºher** erwartet, was auf eine **Geschwindigkeitsfront** hindeutet.<br>
            <span class="font-bold text-yellow-300">Total Bt (nT)</span>: Der **Gesamtwert** des Magnetfelds. Werte **√ºber $15\text{ nT}$** sind hoch (oft assoziiert mit Sto√üwellen).
            <br><span class="font-bold text-red-400">‚¨áÔ∏è Bz</span>: Zeigt die **S√ºdrichtung** des Magnetfelds an, ein kritischer Indikator f√ºr geomagnetische Aktivit√§t und Subst√ºrme.<br>
            <span class="font-bold text-yellow-300">üí• STAU! Dyn. Druck</span>: Zeigt eine **starke Kompressionszone (SIR/Sto√üwelle)** an (Dichte > $15\text{ p/cm}^3$ und Druck > $5\text{ nPa}$).<br>
            <span class="font-bold text-red-400">Dyn. Druck (nPa)</span>: Werte **√ºber $10\text{ nPa}$** sind stark erh√∂ht und deuten auf eine erhebliche Magnetosph√§ren-Kompression hin.<br>
            <span class="font-bold text-red-400">üö® SCI (V¬∑Bs)</span>: Hohe Werte (**> 3500**) signalisieren ein **hohes Potenzial f√ºr Subst√ºrme** (starke Polarlichter).
            <br><span class="font-bold text-red-400">Krit. Aufbauzeit (h)</span>: Die **Mindestdauer**, die dieser Zustand anhalten muss, um einen Sturm auszul√∂sen. **Niedrigere Werte sind kritischer.**
            <br><span class="font-bold text-red-300">‚ö†Ô∏è Gesch. Sturmbeginn</span>: Die **gesch√§tzte fr√ºheste Zeit** f√ºr den **Beginn des geomagnetischen Sturms** (Ankunft + Aufbauzeit).
            <br>Hinweis: Die Daten werden vom NOAA Space Weather Prediction Center (SWPC) bereitgestellt und am L1-Punkt gemessen. Die Tabelle wird jede Minute automatisch aktualisiert.
        </p>
    </div>

    <script type="module">
        // --- Anwendungskonstanten ---
        const PLASMA_API_URL = 'https://services.swpc.noaa.gov/products/solar-wind/plasma-1-day.json';
        const MAG_API_URL = 'https://services.swpc.noaa.gov/products/solar-wind/mag-1-day.json';
        
        const L1_DISTANCE_KM = 1500000;
        const MS_PER_SEC = 1000;
        const TWO_HOURS_MS = 2 * 60 * 60 * 1000;
        const THIRTY_MINUTES_MS = 30 * 60 * 1000;
        const REFRESH_INTERVAL_MS = 60 * 1000;
        
        // Konstante f√ºr die Berechnung des Dynamischen Drucks in nPa
        // Formel: P_dyn (nPa) ‚âà 1.672 * 10^-6 * Density (p/cm¬≥) * Speed (km/s)^2
        const DYNAMIC_PRESSURE_FACTOR = 0.001672;
        const CRITICAL_PRESSURE_NPA = 10.0; // Schwellenwert f√ºr starke Kompression
        const CRITICAL_DENSITY = 15.0; // Schwellenwert f√ºr Kompressions-Ereignisse (SIR/Sto√üwelle)

        // KONSTANTEN F√úR SUBSTORM COUPLING INDEX (SCI)
        // SCI ‚âà Speed * max(0, -Bz) - Vereinfachte Kopplungsfunktion V * Bs
        const SCI_WATCH_LOW = 1000; 
        const SCI_WATCH_ELEVATED = 2000; 
        const SCI_WATCH_HIGH = 3500; 
        
        // KONSTANTEN F√úR KRITISCHE AUFBAUZEIT (VEREINFACHTE REGELN)
        const SCI_DURATION_HIGH_H = 1.75; // 1.5 bis 2.0 Stunden
        const SCI_DURATION_ELEVATED_H = 2.5; // 2.0 bis 3.0 Stunden
        const SCI_DURATION_MEDIUM_H = 3.0; // ca. 3.0 Stunden
        const SCI_DURATION_LOW_H = 100.0; // Platzhalter f√ºr > 3.0 h (zum Sortieren)
        const CRITICAL_BT = 15.0; // Schwellenwert f√ºr hohes Totalfeld

        // --- DOM-Elemente ---
        const tableBody = document.getElementById('table-body');
        const plasmaTable = document.getElementById('plasma-table');
        const loadingIndicator = document.getElementById('loading-indicator');
        const statusMessage = document.getElementById('status-message');
        const headers = document.querySelectorAll('.header-cell');

        let allData = [];
        let sortColumn = 'time_tag';
        let sortDirection = 'desc';

        // =========================================================================
        // === Allgemeine Hilfsfunktionen ===
        // =========================================================================
        
        /**
         * Gibt das qualitative Substurm-Risiko basierend auf dem SCI zur√ºck.
         */
        const getSciRiskLevel = (sci) => {
            if (typeof sci !== 'number' || sci < 0) return 'N/A';
            if (sci >= SCI_WATCH_HIGH) return 'üö® HOCH (> 3500)';
            if (sci >= SCI_WATCH_ELEVATED) return '‚ö†Ô∏è Erh√∂ht (> 2000)';
            if (sci >= SCI_WATCH_LOW) return 'Mittel (> 1000)';
            return 'Gering';
        };

        /**
         * Liefert die kritische Dauer in Stunden (als Zahl) basierend auf dem SCI-Wert.
         */
        const getRequiredBuildupDuration = (sci) => {
            if (typeof sci !== 'number' || sci < SCI_WATCH_LOW) return SCI_DURATION_LOW_H; 
            if (sci >= SCI_WATCH_HIGH) return SCI_DURATION_HIGH_H;
            if (sci >= SCI_WATCH_ELEVATED) return SCI_DURATION_ELEVATED_H;
            return SCI_DURATION_MEDIUM_H; 
        };

        /**
         * Konvertiert den NOAA-Zeitstempel-String in ein UTC-Date-Objekt
         */
        const parseUtcTimeTag = (timeTag) => {
            return new Date(timeTag.replace(' ', 'T') + 'Z');
        };

        /**
         * Formatiert Zeitstempel mit Datum und Uhrzeit
         */
        const formatTime = (date) => {
            if (!(date instanceof Date) || isNaN(date)) return 'N/A';
            const options = {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hour12: false,
                timeZone: 'UTC'
            };
            return date.toLocaleString('de-DE', options) + ' UTC';
        };

        /**
         * F√ºhrt die Berechnung der gesch√§tzten Ankunftszeit, des Dynamischen Drucks, 
         * des SCI und der gesch√§tzten Sturmbeginn-Zeit durch
         */
        const calculateArrival = (entry) => {
            const speed = parseFloat(entry.speed);
            const density = parseFloat(entry.density);
            const bx = parseFloat(entry.bx_nt);
            const by = parseFloat(entry.by_nt);
            const bz = parseFloat(entry.bz_nt);
            const timeTag = entry.time_tag;

            // 1. Berechnung des Magnetischen Totalwerts (Bt)
            let totalBt = 'N/A';
            if (!isNaN(bx) && !isNaN(by) && !isNaN(bz)) {
                totalBt = Math.sqrt(bx*bx + by*by + bz*bz);
            } else if (entry.bt_nt) {
                 totalBt = parseFloat(entry.bt_nt); // Falls Bt direkt verf√ºgbar ist
            }

            // 2. Berechnung des Dynamischen Drucks (nPa)
            let dynamicPressure = 'N/A';
            if (!isNaN(speed) && speed > 0 && !isNaN(density) && density >= 0) {
                dynamicPressure = DYNAMIC_PRESSURE_FACTOR * density * (speed * speed);
            }
            
            // 3. Berechnung des Substorm Coupling Index (SCI)
            let sci = 'N/A';
            if (!isNaN(speed) && speed > 0 && !isNaN(bz)) {
                // SCI = Speed * max(0, -Bz) -> Nur relevant, wenn Bz s√ºdlich (negativ) ist
                sci = speed * Math.max(0, -bz);
            }

            // 4. Qualitative Risikobewertung
            const sciRiskLevel = getSciRiskLevel(sci);

            // 5. Kritische Aufbauzeit (vereinfachte Regel)
            const criticalBuildupDuration = getRequiredBuildupDuration(sci);
            
            // 6. Berechnung der Ankunftszeit (nur wenn Geschwindigkeit g√ºltig)
            let travelTimeHours = 'N/A';
            let travelTimeMinutes = 'N/A';
            let travelTimeMs = null;
            let arrivalDate = 'Ung√ºltige Geschw.';
            let estimatedOnset = 'N/A';

            if (!isNaN(speed) && speed > 0 && speed <= 10000) {
                const travelTimeSeconds = L1_DISTANCE_KM / speed;
                travelTimeHours = travelTimeSeconds / 3600;
                travelTimeMinutes = travelTimeSeconds / 60;
                travelTimeMs = travelTimeSeconds * MS_PER_SEC;
                const measurementDate = parseUtcTimeTag(timeTag);
                arrivalDate = new Date(measurementDate.getTime() + travelTimeMs);
            }
            
            // 7. Gesch√§tzte Sturmbeginn-Zeit (Ankunftszeit + Kritische Aufbauzeit)
            if (arrivalDate instanceof Date && !isNaN(arrivalDate) && criticalBuildupDuration !== SCI_DURATION_LOW_H) {
                // Kritische Dauer in Millisekunden umrechnen
                const durationMs = criticalBuildupDuration * 60 * 60 * 1000;
                estimatedOnset = new Date(arrivalDate.getTime() + durationMs);
            }


            return {
                ...entry,
                dynamic_pressure_npa: dynamicPressure,
                substorm_coupling_index: sci, 
                sci_risk_level: sciRiskLevel, 
                critical_buildup_duration_h: criticalBuildupDuration,
                total_bt: totalBt, // NEU
                travel_time_h: travelTimeHours,
                travel_time_m: travelTimeMinutes, // NEU
                travel_time_ms: travelTimeMs,
                arrival_time: arrivalDate,
                estimated_onset_time: estimatedOnset, 
            };
        };


        // =========================================================================
        // === Tabellen- und UI-Logik ===
        // =========================================================================

        /**
         * Rendert die Daten in die HTML-Tabelle
         */
        const renderTable = (data) => {
            tableBody.innerHTML = '';
            if (data.length === 0) {
                statusMessage.textContent = 'Keine Daten in den letzten 2 Stunden zum Anzeigen vorhanden.';
                statusMessage.classList.remove('hidden', 'bg-red-900', 'bg-green-900/50');
                statusMessage.classList.add('bg-yellow-900', 'text-yellow-400');
                plasmaTable.classList.add('hidden');
                return;
            }
            
            const nowUtc = new Date();

            data.forEach((entry, index) => {
                
                let isArrived = false;
                if (entry.arrival_time instanceof Date && !isNaN(entry.arrival_time)) {
                    if (entry.arrival_time.getTime() <= nowUtc.getTime()) {
                        isArrived = true;
                    }
                }

                let rowClass = index % 2 !== 0 ? 'bg-gray-700/50' : '';
                rowClass += isArrived ? ' highlight-row' : '';

                const row = document.createElement('tr');
                row.className = `border-b border-gray-700 hover:bg-gray-700 transition duration-150 ${rowClass}`;

                // --- Bz (Magnetfeld) Verbesserungen ---
                let bzColor = 'text-gray-300';
                let bzIcon = '';
                const bz = parseFloat(entry.bz_nt);
                if (!isNaN(bz)) {
                    if (bz < -5) { 
                        bzColor = 'text-red-400 font-bold';
                        bzIcon = '‚¨áÔ∏è'; 
                    } else if (bz < 0) {
                        bzColor = 'text-orange-300';
                        bzIcon = '‚Üì'; 
                    } else if (bz > 5) {
                        bzColor = 'text-blue-300';
                        bzIcon = '‚¨ÜÔ∏è'; 
                    } else if (bz > 0) {
                        bzColor = 'text-green-400';
                        bzIcon = '‚Üë'; 
                    }
                }

                // Farben f√ºr die Geschwindigkeit
                let speedColor = 'text-green-400';
                const speed = parseFloat(entry.speed);
                if (speed > 550) {
                    speedColor = 'text-red-400 font-bold';
                } else if (speed > 450) {
                    speedColor = 'text-yellow-400';
                }

                // --- Dyn. Druck Hervorhebung und Kompression ---
                let pressureColor = 'text-gray-300';
                let compressionIcon = '';
                const pressure = entry.dynamic_pressure_npa;
                const density = parseFloat(entry.density);

                if (typeof pressure === 'number') {
                    if (pressure > CRITICAL_PRESSURE_NPA) {
                        pressureColor = 'text-red-400 font-bold'; // Kritisch
                    } else if (pressure > 5.0) {
                        pressureColor = 'text-orange-400'; // Erh√∂ht
                    } else if (pressure < 0.5) {
                        pressureColor = 'text-gray-500'; // Sehr niedrig
                    }
                }

                // Kompressions-Indikator (SIR/Sto√üwelle): Hohe Dichte UND erh√∂hter Druck
                if (!isNaN(density) && density >= CRITICAL_DENSITY && typeof pressure === 'number' && pressure > 5.0) {
                    pressureColor = 'text-yellow-300 font-extrabold'; 
                    compressionIcon = 'üí• STAU!'; 
                }

                // --- Total Bt Hervorhebung ---
                let btColor = 'text-gray-300';
                const totalBt = entry.total_bt;
                if (typeof totalBt === 'number' && totalBt > CRITICAL_BT) {
                    btColor = 'text-yellow-300 font-bold';
                } else if (typeof totalBt === 'number' && totalBt < 5.0) {
                    btColor = 'text-gray-500';
                }

                // --- SCI (Substorm Coupling Index) und Reihen-Klassifizierung ---
                const sci = entry.substorm_coupling_index;
                let sciColor = 'text-gray-300';
                
                if (typeof sci === 'number') {
                    if (sci > SCI_WATCH_HIGH) {
                        sciColor = 'text-red-400 font-extrabold';
                        // H√∂chste Warnstufe: Hintergrund hervorheben
                        row.classList.add('substorm-watch-high'); 
                    } else if (sci > SCI_WATCH_ELEVATED) {
                        sciColor = 'text-orange-400 font-bold';
                        row.classList.add('substorm-watch-elevated');
                    } else if (sci > SCI_WATCH_LOW) {
                        sciColor = 'text-yellow-400';
                    }
                }
                
                const sciValue = typeof sci === 'number' ? sci.toFixed(0) : String(sci);
                
                row.innerHTML += `<td class="py-3 px-6 text-left">${formatTime(parseUtcTimeTag(entry.time_tag))}</td>`;
                row.innerHTML += `<td class="py-3 px-6 text-left ${speedColor}">${parseFloat(entry.speed).toFixed(1)}</td>`;
                row.innerHTML += `<td class="py-3 px-6 text-left">${parseFloat(entry.density).toFixed(2)}</td>`;
                
                // Dynamischer Druck Zelle
                const pressureValue = typeof pressure === 'number' ? pressure.toFixed(2) : String(pressure);
                row.innerHTML += `<td class="py-3 px-6 text-left ${pressureColor}">
                    ${compressionIcon ? `<span class="mr-1">${compressionIcon}</span>` : ''}${pressureValue}
                </td>`;
                
                // Total Bt Zelle (NEU)
                const totalBtValue = typeof totalBt === 'number' ? totalBt.toFixed(1) : String(totalBt);
                row.innerHTML += `<td class="py-3 px-6 text-left ${btColor}">${totalBtValue}</td>`;
                
                // Bz (nT) - Mit grafischem Pfeil-Indikator
                row.innerHTML += `<td class="py-3 px-6 text-left ${bzColor}">
                    ${bzIcon ? `<span class="mr-1">${bzIcon}</span>` : ''}${parseFloat(entry.bz_nt).toFixed(1)}
                </td>`;

                // SCI (Substorm Coupling Index) Zelle - ZEIGT DEN WERT AN
                 row.innerHTML += `<td class="py-3 px-6 text-left ${sciColor}">
                    ${sciValue}
                </td>`;
                
                // Kritische Aufbauzeit
                let durationColor = 'text-gray-400';
                const duration = entry.critical_buildup_duration_h;
                let durationText = duration === SCI_DURATION_LOW_H ? '> 3.0 h' : 'N/A';

                if (duration === SCI_DURATION_HIGH_H) {
                    durationColor = 'text-red-400 font-bold';
                    durationText = '1.5 - 2.0 h';
                } else if (duration === SCI_DURATION_ELEVATED_H) {
                    durationColor = 'text-orange-400';
                    durationText = '2.0 - 3.0 h';
                } else if (duration === SCI_DURATION_MEDIUM_H) {
                    durationColor = 'text-yellow-400';
                    durationText = 'ca. 3.0 h';
                }
                
                row.innerHTML += `<td class="py-3 px-6 text-left ${durationColor}">${durationText}</td>`;
                
                // Gesch√§tzte Sturmbeginn-Zeit
                let onsetTimeText = 'N/A';
                let onsetTimeColor = 'text-gray-400';
                
                if (entry.estimated_onset_time instanceof Date && !isNaN(entry.estimated_onset_time)) {
                    // Zeit (HH:MM:SS) aus dem formatierten String extrahieren
                    onsetTimeText = formatTime(entry.estimated_onset_time).substring(11, 20); 
                    
                    const diffMs = entry.estimated_onset_time.getTime() - nowUtc.getTime();

                    if (diffMs > 0 && diffMs <= THIRTY_MINUTES_MS) {
                        onsetTimeColor = 'text-red-300 font-bold';
                        onsetTimeText = `‚ö†Ô∏è SOON! ${onsetTimeText}`;
                    } else if (diffMs <= 0) {
                        onsetTimeColor = 'text-red-400 font-extrabold';
                        onsetTimeText = `‚ö†Ô∏è JETZT! ${onsetTimeText}`;
                    } else {
                        onsetTimeColor = 'text-blue-300';
                    }
                }
                
                row.innerHTML += `<td class="py-3 px-6 text-left ${onsetTimeColor}">${onsetTimeText}</td>`;

                // Substurm-Risiko Zelle - ZEIGT DEN LEVEL-STRING AN
                let riskColor = '';
                if (entry.sci_risk_level.startsWith('üö® HOCH')) {
                    riskColor = 'text-red-400 font-bold';
                } else if (entry.sci_risk_level.startsWith('‚ö†Ô∏è Erh√∂ht')) {
                    riskColor = 'text-orange-400';
                } else if (entry.sci_risk_level.startsWith('Mittel')) {
                    riskColor = 'text-yellow-400';
                } else {
                    riskColor = 'text-gray-400';
                }

                row.innerHTML += `<td class="py-3 px-6 text-left ${riskColor}">
                    ${entry.sci_risk_level}
                </td>`;


                // --- √úberhol-Indikator (Schnelleres Plasma √ºberholt √§lteres) ---
                let isOvertaking = false;
                if (index < data.length - 1) {
                    const nextEntry = data[index + 1]; // √Ñlterer Datenpunkt
                    const currentArrival = entry.arrival_time instanceof Date ? entry.arrival_time.getTime() : Infinity;
                    const nextArrival = nextEntry.arrival_time instanceof Date ? nextEntry.arrival_time.getTime() : Infinity;

                    // Wenn die gesch√§tzte Ankunftszeit des neueren Eintrags FR√úHER ist, wird √ºberholt.
                    if (currentArrival < nextArrival) {
                        isOvertaking = true;
                    }
                }
                
                // Ankunftszeit
                let arrivalTimeCell = `<td class="py-3 px-6 text-left">`;
                
                if (entry.arrival_time instanceof Date && !isNaN(entry.arrival_time)) {
                    const diffMs = entry.arrival_time.getTime() - nowUtc.getTime();
                    
                    let timeText = entry.arrival_time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: 'UTC' }) + ' UTC';
                    let cellClass = '';

                    // 1. Overtaking Markierung (h√∂chste Priorit√§t f√ºr visuelle Aufmerksamkeit)
                    if (isOvertaking) {
                        cellClass += ' bg-pink-900/40 border-l border-pink-600';
                        timeText = `<span class="text-pink-400 font-extrabold">üèéÔ∏è √úBERHOLT! ${timeText}</span>`;
                    }
                    
                    // 2. Ankunft innerhalb 30 Minuten
                    else if (diffMs > 0 && diffMs <= THIRTY_MINUTES_MS) {
                        cellClass = 'bg-blue-900/40 border-r border-blue-600';
                        timeText = `<span class="text-blue-300 font-extrabold">üîú ${timeText}</span>`;
                    } 
                    
                    // 3. Bereits angekommen
                    else if (isArrived) {
                        timeText = `<span class="font-bold text-gray-200">${timeText}</span>`;
                    } 
                    
                    // 4. Normal
                    else {
                        timeText = `<span class="font-medium">${timeText}</span>`;
                    }

                    arrivalTimeCell = `<td class="py-3 px-6 text-left ${cellClass}">`;
                    arrivalTimeCell += timeText;
                    
                } else {
                    arrivalTimeCell += `<span class="text-red-500">${entry.arrival_time}</span>`;
                }
                arrivalTimeCell += `</td>`;
                row.innerHTML += arrivalTimeCell;
                
                // Laufzeit (Minuten) - NEU
                let travelTimeMCell = `<td class="py-3 px-6 text-left">`;
                if (typeof entry.travel_time_m === 'number') {
                    travelTimeMCell += `${entry.travel_time_m.toFixed(0)} min`;
                } else {
                    travelTimeMCell += `N/A`;
                }
                travelTimeMCell += `</td>`;
                row.innerHTML += travelTimeMCell;


                // Laufzeit (h)
                let travelTimeCell = `<td class="py-3 px-6 text-left">`;
                if (typeof entry.travel_time_h === 'number') {
                    travelTimeCell += `${entry.travel_time_h.toFixed(2)} h`;
                } else {
                    travelTimeCell += `N/A`;
                }
                travelTimeCell += `</td>`;
                row.innerHTML += travelTimeCell;

                tableBody.appendChild(row);
            });
            plasmaTable.classList.remove('hidden');
        };

        /**
         * Sortiert die Daten basierend auf der ausgew√§hlten Spalte und Richtung
         */
        const sortData = () => {
            const keyMap = {
                'time_tag': d => parseUtcTimeTag(d.time_tag).getTime(),
                'speed': d => parseFloat(d.speed) || -Infinity,
                'density': d => parseFloat(d.density) || -Infinity,
                'dynamic_pressure_npa': d => typeof d.dynamic_pressure_npa === 'number' ? d.dynamic_pressure_npa : -Infinity,
                'total_bt': d => typeof d.total_bt === 'number' ? d.total_bt : -Infinity,
                'bz_nt': d => parseFloat(d.bz_nt) || -Infinity,
                'substorm_coupling_index': d => typeof d.substorm_coupling_index === 'number' ? d.substorm_coupling_index : -Infinity,
                // Sortiere die kritische Dauer in aufsteigender Reihenfolge (kleinere Dauer ist kritischer)
                'critical_buildup_duration_h': d => typeof d.critical_buildup_duration_h === 'number' ? d.critical_buildup_duration_h : Infinity, 
                // Sortiere nach gesch√§tztem Beginn
                'estimated_onset_time': d => d.estimated_onset_time instanceof Date ? d.estimated_onset_time.getTime() : Infinity,
                'sci_risk_level': d => typeof d.substorm_coupling_index === 'number' ? d.substorm_coupling_index : -Infinity, 
                'arrival_time': d => d.travel_time_ms !== null ? parseUtcTimeTag(d.time_tag).getTime() + d.travel_time_ms : -Infinity,
                'travel_time_h': d => d.travel_time_h !== 'N/A' ? d.travel_time_h : -Infinity,
                'travel_time_m': d => d.travel_time_m !== 'N/A' ? d.travel_time_m : -Infinity
            };

            allData.sort((a, b) => {
                const valA = keyMap[sortColumn](a);
                const valB = keyMap[sortColumn](b);

                let comparison = 0;
                if (valA > valB) {
                    comparison = 1;
                } else if (valA < valB) {
                    comparison = -1;
                }

                // Ausnahme: ASC f√ºr Kritische Aufbauzeit, Sturmbeginn und Laufzeiten (k√ºrzer ist bald)
                const isAscendingSort = sortDirection === 'asc' || 
                                        sortColumn === 'critical_buildup_duration_h' || 
                                        sortColumn === 'estimated_onset_time' ||
                                        sortColumn === 'travel_time_h' || 
                                        sortColumn === 'travel_time_m';
                
                // F√ºr Bz und SCI (Risiko) ist DESC die kritischere Richtung (gr√∂√üere Zahl/negative Zahl)
                if (sortColumn === 'bz_nt') {
                    // Bz: Gr√∂√üere NEGATIVE Zahl ist kritischer. Daher DESC (negativ zuerst)
                    return sortDirection === 'asc' ? comparison : comparison * -1;
                }


                return isAscendingSort ? comparison : comparison * -1;
            });

            document.querySelectorAll('[data-sort-icon]').forEach(icon => icon.textContent = '');
            const currentIcon = document.querySelector(`[data-sort-icon="${sortColumn}"]`);
            if (currentIcon) {
                // Anzeige der Sortierrichtung
                if (sortColumn === 'critical_buildup_duration_h' || sortColumn === 'estimated_onset_time' || sortColumn === 'travel_time_h' || sortColumn === 'travel_time_m') {
                    // F√ºr diese Spalten ist ASC (‚Üë) die "logische" Standardrichtung (bald/kurz zuerst)
                    currentIcon.textContent = sortDirection === 'asc' ? '‚Üë' : '‚Üì';
                } else {
                    // F√ºr alle anderen ist DESC (‚Üì) die Standardrichtung (neueste/h√∂chste zuerst)
                    currentIcon.textContent = sortDirection === 'asc' ? '‚Üë' : '‚Üì';
                }
            }
            // Standardm√§√üig nach Zeit absteigend sortieren
            if (sortColumn === 'time_tag') {
                const defaultIcon = document.querySelector(`[data-sort-icon="time_tag"]`);
                defaultIcon.textContent = '‚Üì';
            }

            renderTable(allData);
        };

        /**
         * Holt die Daten von einem NOAA-Endpunkt
         */
        const fetchData = async (url) => {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP-Fehler beim Laden von ${url}: ${response.status}`);
            }
            const rawData = await response.json();
            return rawData.slice(1);
        };


        /**
         * Hauptfunktion zum Abrufen und Verarbeiten der Daten
         */
        const fetchSolarWindData = async () => {
            loadingIndicator.classList.remove('hidden');
            statusMessage.classList.add('hidden');
            plasmaTable.classList.add('hidden');

            try {
                // Exponential Backoff f√ºr Fetch-Anfragen (nur zur Simulation, da die Umgebung dies verwaltet)
                // Bei einem echten Fehler w√ºrde ich hier Wiederholungslogik implementieren.
                
                const [plasmaDataRaw, magDataRaw] = await Promise.all([
                    fetchData(PLASMA_API_URL),
                    fetchData(MAG_API_URL)
                ]);

                // Indizes f√ºr das Magnetfeld-Array:
                const MAG_TIME_INDEX = 0;
                const MAG_BX_INDEX = 1;
                const MAG_BY_INDEX = 2;
                const MAG_BZ_INDEX = 3;
                const MAG_BT_INDEX = 4;

                const magMap = new Map();
                magDataRaw.forEach(row => {
                    const timeTag = row[MAG_TIME_INDEX];
                    // √úberpr√ºfung, ob die kritischen Werte verf√ºgbar sind
                    if (row[MAG_BX_INDEX] !== 'null' && row[MAG_BY_INDEX] !== 'null' && row[MAG_BZ_INDEX] !== 'null') {
                        magMap.set(timeTag, {
                            bx_nt: row[MAG_BX_INDEX],
                            by_nt: row[MAG_BY_INDEX],
                            bz_nt: row[MAG_BZ_INDEX],
                            bt_nt: row[MAG_BT_INDEX] || 'N/A' // Bt ist Index 4, optional
                        });
                    }
                });

                const processedData = plasmaDataRaw.map(row => {
                    const timeTag = row[0];
                    const magEntry = magMap.get(timeTag) || { bx_nt: 'N/A', by_nt: 'N/A', bz_nt: 'N/A', bt_nt: 'N/A' };
                    
                    const entry = {
                        time_tag: timeTag,
                        density: row[1],
                        speed: row[2],
                        bx_nt: magEntry.bx_nt, // Hinzugef√ºgt
                        by_nt: magEntry.by_nt,
                        bz_nt: magEntry.bz_nt,
                        bt_nt: magEntry.bt_nt, // Hinzugef√ºgt
                    };
                    return calculateArrival(entry);
                });

                if (processedData.length > 0) {
                    const latestEntry = processedData.reduce((prev, current) => {
                        if (!current.time_tag) return prev; 
                        if (!prev.time_tag) return current;

                        const prevTime = parseUtcTimeTag(prev.time_tag).getTime();
                        const currTime = parseUtcTimeTag(current.time_tag).getTime();

                        return (currTime > prevTime) ? current : prev;
                    }, processedData.find(e => e.time_tag) || { time_tag: '1970-01-01 00:00:00.000' });

                    const latestTimeMs = parseUtcTimeTag(latestEntry.time_tag).getTime();
                    const cutoffTimeMs = latestTimeMs - TWO_HOURS_MS;

                    allData = processedData.filter(entry => {
                        const entryTimeMs = parseUtcTimeTag(entry.time_tag).getTime();
                        return entryTimeMs >= cutoffTimeMs;
                    });

                    statusMessage.textContent = `Daten (24h Quellen) erfolgreich geladen. Zeige ${allData.length} Eintr√§ge der letzten 2 Stunden (bis zum letzten Messwert, UTC). N√§chste Aktualisierung in 1 Minute.`;
                    statusMessage.classList.remove('hidden', 'bg-red-900', 'bg-yellow-900');
                    statusMessage.classList.add('bg-green-900/50', 'text-green-400', 'font-semibold');

                } else {
                    allData = [];
                    statusMessage.textContent = 'Daten erfolgreich geladen, aber keine Eintr√§ge in den letzten 2 Stunden gefunden.';
                    statusMessage.classList.remove('hidden', 'bg-red-900', 'bg-green-900/50');
                    statusMessage.classList.add('bg-yellow-900', 'text-yellow-400');
                }

                sortData();

            } catch (error) {
                console.error("Fehler beim Abrufen der Daten:", error);
                statusMessage.textContent = `Fehler beim Laden der Daten: ${error.message}. N√§chste Aktualisierung in 1 Minute.`;
                statusMessage.classList.remove('hidden', 'bg-green-900/50', 'bg-yellow-900');
                statusMessage.classList.add('bg-red-900', 'text-red-400');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        };

        /**
         * Startet den initialen Ladevorgang und richtet den Auto-Refresh-Intervall ein.
         */
        const startApp = () => {
            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.sortKey;
                    if (sortColumn === key) {
                        // Bei Sortierung nach Bz wollen wir, dass die negative Zahl (kritisch) zuerst kommt
                        if (key === 'bz_nt') {
                            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                        }
                    } else {
                        sortColumn = key;
                        
                        // Standard Sortierung f√ºr kritische Werte ist DESC (h√∂chster Wert zuerst)
                        // Ausnahme: Zeit/Dauer (ASC f√ºr k√ºrzer/fr√ºher)
                        if (key === 'critical_buildup_duration_h' || key === 'estimated_onset_time' || key === 'travel_time_h' || key === 'travel_time_m') {
                            sortDirection = 'asc'; 
                        } else {
                            sortDirection = 'desc'; 
                        }

                         // Bz-Standard-Sortierung: DESC (negativ, d.h. s√ºdlich, zuerst)
                         if (key === 'bz_nt') {
                            sortDirection = 'asc'; 
                        }
                    }
                    sortData();
                });
            });

            fetchSolarWindData();
            setInterval(fetchSolarWindData, REFRESH_INTERVAL_MS);
        };

        window.onload = startApp;
    </script>
</body>
</html>
