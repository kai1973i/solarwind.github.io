<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solarwind-Plasma-Daten und Substurm-Kopplungsindex</title>
    <!-- Tailwind CSS laden -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN f√ºr das Diagramm laden -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- Luxon und Chart.js Adapter f√ºr die "time" Achse hinzuf√ºgen -->
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.min.js"></script>
    <!-- Zoom Plugin f√ºr Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        /* Spezifische Schriftart */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dunkler Hintergrund */
            color: #c9d1d9; /* Heller Text */
        }
        .header-cell {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .header-cell:hover {
            background-color: #21262d;
        }
        .loading-animation {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #58a6ff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* HIGHTLIGHT-KLASSE: Markiert Daten, deren Ankunft theoretisch bereits erfolgt ist */
        .highlight-row {
            background-color: #1a222e; /* Dunkler, dezenter Blauton */
            border-left: 4px solid #3b82f6; /* Subtiler blauer Rand */
        }
        .highlight-row:hover {
            background-color: #242c38 !important;
        }
        .substorm-watch-high {
            background-color: #450a0a !important; /* Dunkelrot */
            border-left: 4px solid #ef4444 !important;
            font-weight: bold;
        }
        .substorm-watch-elevated {
            background-color: #422006 !important; /* Dunkelorange */
            border-left: 4px solid #f97316 !important;
        }
        .status-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
        }
        .status-metric {
            background-color: #161b22;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #30363d;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        .metric-value {
            font-size: 1.875rem; /* text-3xl */
            font-weight: 800; /* font-extrabold */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-extrabold mb-2 text-blue-400">
            Solarwind-Plasma-Daten (L1-Punkt)
        </h1>
        <p class="text-lg mb-6 text-gray-400">
            Daten der NOAA SWPC (Plasma und Magnetfeld) mit berechneter gesch√§tzter Ankunftszeit und Substurm-Kopplungsindex.
        </p>

        <!-- Echtzeit-Statuskarte (Zeigt die Auswirkung des L1-Pakets) -->
        <div id="current-status-card" class="mb-8 status-card-grid">
            <div class="status-metric">
                <p class="text-sm uppercase text-gray-400">Neuster Messwert (L1)</p>
                <p id="latest-time-tag" class="metric-value text-gray-300">-</p>
            </div>
            <div class="status-metric">
                <p class="text-sm uppercase text-gray-400">Gesch. Ankunft (Erde)</p>
                <p id="arrival-time-status" class="metric-value text-blue-400">-</p>
            </div>
            <div class="status-metric">
                <p class="text-sm uppercase text-gray-400">Bz (Kopplung, nT)</p>
                <p id="bz-status" class="metric-value text-gray-300">-</p>
            </div>
            <div class="status-metric">
                <p class="text-sm uppercase text-gray-400">Prog. AL-Index</p>
                <p id="al-potential-status" class="metric-value text-gray-300">-</p>
            </div>
        </div>
        
        <!-- Diagramm-Container -->
        <div class="mb-8 p-4 bg-gray-800 rounded-lg shadow-2xl">
            <h2 class="text-xl font-bold mb-4 text-blue-300">Trend-Diagramm (letzte 2 Stunden)</h2>
            <div class="relative h-96">
                <canvas id="solarWindChart"></canvas>
            </div>
            <div class="mt-4 text-sm text-center text-gray-400">
                <span class="mr-4">Geschw./Dichte auf der linken Y-Achse.</span>
                <span class="mr-4">Bt/Bz (Magnetfeld) auf der rechten Y-Achse.</span>
                (Nutzen Sie das Mausrad oder halten Sie die Shift-Taste gedr√ºckt, um zu zoomen.)
            </div>
        </div>

        <!-- Status- und Ladeanzeige -->
        <div id="status-message" class="text-center p-4 my-4 bg-gray-800 rounded-lg shadow-lg hidden"></div>
        <div id="loading-indicator" class="flex justify-center items-center p-8">
            <div class="loading-animation"></div>
            <span class="ml-4 text-xl text-blue-400">Daten werden geladen...</span>
        </div>

        <!-- Tabelle f√ºr die Daten -->
        <div id="data-container" class="overflow-x-auto">
            <table id="plasma-table" class="min-w-full bg-gray-800 rounded-lg shadow-2xl hidden">
                <thead>
                    <tr class="bg-blue-600/80 text-white uppercase text-sm leading-normal">
                        <!-- Plasmadaten & Zeiten -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="time_tag">
                            Messzeitpunkt (L1)
                            <span data-sort-icon="time_tag" class="ml-1">‚Üì</span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="speed">
                            Geschw. (km/s)
                            <span data-sort-icon="speed" class="ml-1"></span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="density">
                            Dichte (p/cm¬≥)
                            <span data-sort-icon="density" class="ml-1"></span>
                        </th>
                        <!-- Dynamischer Druck -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="dynamic_pressure_npa">
                            Dyn. Druck (nPa)
                            <span data-sort-icon="dynamic_pressure_npa" class="ml-1"></span>
                        </th>
                        <!-- Magnetfelddaten -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="total_bt">
                            Total Bt (nT)
                            <span data-sort-icon="total_bt" class="ml-1"></span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="bz_nt">
                            Bz (nT)
                            <span data-sort-icon="bz_nt" class="ml-1"></span>
                        </th>
                        <!-- NEU: Prognostizierter AL-Index Spalte -->
                         <th class="py-3 px-6 text-left header-cell" data-sort-key="estimated_al_potential">
                            üìâ Prognostizierter AL-Index (nT)
                            <span data-sort-icon="estimated_al_potential" class="ml-1"></span>
                        </th>
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="substorm_coupling_index">
                            ‚ö° SCI (V¬∑Bs)
                            <span data-sort-icon="substorm_coupling_index" class="ml-1"></span>
                        </th>
                        <!-- Gesch√§tzte Sturmbeginn-Zeit -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="estimated_onset_time">
                            Gesch. Sturmbeginn (UTC)
                            <span data-sort-icon="estimated_onset_time" class="ml-1"></span>
                        </th>
                        <!-- Substurm-Risiko -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="sci_risk_level">
                            Risiko-Level
                            <span data-sort-icon="sci_risk_level" class="ml-1"></span>
                        </th>
                        <!-- Ankunftszeit -->
                        <th class="py-3 px-6 text-left header-cell" data-sort-key="arrival_time">
                            Gesch. Ankunftszeit (Erde)
                            <span data-sort-icon="arrival_time" class="ml-1"></span>
                        </th>
                    </tr>
                </thead>
                <tbody id="table-body" class="text-gray-300 text-sm font-light">
                    <!-- Daten werden hier durch JavaScript eingef√ºgt -->
                </tbody>
            </table>
        </div>

        <p class="mt-6 text-xs text-gray-500">
            <span class="font-bold text-blue-400">Hervorgehobene Zeilen</span> (blaue Markierung) sind bereits auf der Erde **angekommen**.<br>
            <span class="font-bold text-pink-400">üèéÔ∏è √úBERHOLT!</span>: Ein sp√§ter gemessener Plasmaabschnitt wird **fr√ºher** erwartet, was auf eine **Geschwindigkeitsfront** hindeutet.<br>
            <span class="font-bold text-yellow-300">Total Bt (nT)</span>: Der **Gesamtwert** des Magnetfelds. Werte **√ºber $15\text{ nT}$** sind hoch (oft assoziiert mit Sto√üwellen).
            <br><span class="font-bold text-red-400">‚¨áÔ∏è Bz</span>: Zeigt die **S√ºdrichtung** des Magnetfelds an, ein kritischer Indikator f√ºr geomagnetische Aktivit√§t und Subst√ºrme. **(Dies ist die wichtigste Information, die einem Boden-Magnetometer-Index vorausgeht)**<br>
            <span class="font-bold text-yellow-300">üí• STAU! Dyn. Druck</span>: Zeigt eine **starke Kompressionszone (SIR/Sto√üwelle)** an (Dichte > $15\text{ p/cm}^3$ und Druck > $5\text{ nPa}$).<br>
            <span class="font-bold text-red-400">Dyn. Druck (nPa)</span>: Werte **√ºber $10\text{ nPa}$** sind stark erh√∂ht und deuten auf eine erhebliche Magnetosph√§ren-Kompression hin.<br>
            <span class="font-bold text-red-400">üö® SCI (V¬∑Bs)</span>: Hohe Werte (**> 3500**) signalisieren ein **hohes Potenzial f√ºr Subst√ºrme** (starke Polarlichter).
            <br><span class="font-bold text-red-300">üìâ Prognostizierter AL-Index (nT)</span>: Basiert auf einer einfachen Korrelation zur Vorhersage der maximalen St√§rke des westlichen Elektrojet-Stromes. **Negativere Werte (z. B. $-200\text{ nT}$ oder mehr)** deuten auf moderate bis starke Aktivit√§t hin (hier wird der Betrag angezeigt).
            <br><span class="font-bold text-red-300">‚ö†Ô∏è Gesch. Sturmbeginn</span>: Die **gesch√§tzte fr√ºheste Zeit** f√ºr den **Beginn des geomagnetischen Sturms** (Ankunft + Aufbauzeit).
            <br>Hinweis: Die Daten werden vom NOAA Space Weather Prediction Center (SWPC) bereitgestellt und am L1-Punkt gemessen. Die Tabelle wird jede Minute automatisch aktualisiert.
        </p>
    </div>

    <script>
        // --- Anwendungskonstanten ---
        const PLASMA_API_URL = 'https://services.swpc.noaa.gov/products/solar-wind/plasma-1-day.json';
        const MAG_API_URL = 'https://services.swpc.noaa.gov/products/solar-wind/mag-1-day.json';
        
        const L1_DISTANCE_KM = 1500000;
        const MS_PER_SEC = 1000;
        const TWO_HOURS_MS = 2 * 60 * 60 * 1000;
        const THIRTY_MINUTES_MS = 30 * 60 * 1000;
        const REFRESH_INTERVAL_MS = 60 * 1000;
        
        // Konstante f√ºr die Berechnung des Dynamischen Drucks in nPa
        const DYNAMIC_PRESSURE_FACTOR = 0.001672;
        const CRITICAL_PRESSURE_NPA = 10.0;
        const CRITICAL_DENSITY = 15.0;

        // KONSTANTEN F√úR SUBSTORM COUPLING INDEX (SCI)
        const SCI_WATCH_LOW = 1000; 
        const SCI_WATCH_ELEVATED = 2000; 
        const SCI_WATCH_HIGH = 3500; 
        
        // KONSTANTEN F√úR KRITISCHE AUFBAUZEIT
        const SCI_DURATION_HIGH_H = 1.75; 
        const SCI_DURATION_ELEVATED_H = 2.5;
        const SCI_DURATION_MEDIUM_H = 3.0;
        const SCI_DURATION_LOW_H = 100.0; 
        const CRITICAL_BT = 15.0; 

        // KONSTANTEN F√úR AL-POTENZIAL
        const AL_SCALING_FACTOR = 0.1;
        const AL_MODERATE_THRESHOLD = 200; // AL > -200 (da AL negativ ist, entspricht -AL > 200)
        const AL_STRONG_THRESHOLD = 500; // AL > -500
        const AL_SEVERE_THRESHOLD = 1000; // AL > -1000

        // --- Globale Variablen ---
        let allData = [];
        let sortColumn = 'time_tag';
        let sortDirection = 'desc';
        let chartInstance = null; // Variable f√ºr die Chart-Instanz

        // --- DOM-Elemente ---
        const tableBody = document.getElementById('table-body');
        const plasmaTable = document.getElementById('plasma-table');
        const loadingIndicator = document.getElementById('loading-indicator');
        const statusMessage = document.getElementById('status-message');
        const headers = document.querySelectorAll('.header-cell');

        // Statuskarten-Elemente
        const latestTimeTagEl = document.getElementById('latest-time-tag');
        const arrivalTimeStatusEl = document.getElementById('arrival-time-status');
        const bzStatusEl = document.getElementById('bz-status');
        const alPotentialStatusEl = document.getElementById('al-potential-status'); // Neues Element

        /**
         * Robuster Parser f√ºr NOAA-Daten, um 'null'/'N/A' sicher in Zahlen umzuwandeln.
         */
        const safeParseFloat = (value) => {
            if (typeof value === 'number') return value;
            if (typeof value === 'string' && (value.toLowerCase() === 'null' || value === 'N/A')) {
                return NaN;
            }
            return parseFloat(value);
        };


        // =========================================================================
        // === Allgemeine Hilfsfunktionen ===
        // =========================================================================
        
        /**
         * Gibt das qualitative Substurm-Risiko basierend auf dem SCI zur√ºck.
         */
        const getSciRiskLevel = (sci) => {
            if (typeof sci !== 'number' || isNaN(sci) || sci < 0) return 'N/A';
            if (sci >= SCI_WATCH_HIGH) return 'üö® HOCH (> 3500)';
            if (sci >= SCI_WATCH_ELEVATED) return '‚ö†Ô∏è Erh√∂ht (> 2000)';
            if (sci >= SCI_WATCH_LOW) return 'Mittel (> 1000)';
            return 'Gering';
        };

        /**
         * Liefert die kritische Dauer in Stunden (als Zahl) basierend auf dem SCI-Wert.
         */
        const getRequiredBuildupDuration = (sci) => {
            if (typeof sci !== 'number' || isNaN(sci) || sci < SCI_WATCH_LOW) return SCI_DURATION_LOW_H; 
            if (sci >= SCI_WATCH_HIGH) return SCI_DURATION_HIGH_H;
            if (sci >= SCI_WATCH_ELEVATED) return SCI_DURATION_ELEVATED_H;
            return SCI_DURATION_MEDIUM_H; 
        };

        /**
         * Konvertiert den NOAA-Zeitstempel-String in ein UTC-Date-Objekt
         */
        const parseUtcTimeTag = (timeTag) => {
            return new Date(timeTag.replace(' ', 'T') + 'Z');
        };

        /**
         * Formatiert Zeitstempel mit Datum und Uhrzeit
         */
        const formatTime = (date) => {
            if (!(date instanceof Date) || isNaN(date)) return 'N/A';
            const options = {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hour12: false,
                timeZone: 'UTC'
            };
            return date.toLocaleString('de-DE', options) + ' UTC';
        };

        /**
         * F√ºhrt die Berechnung aller abgeleiteten Parameter durch
         * Stellt sicher, dass alle kritischen Felder in Zahlen konvertiert werden
         */
        const calculateDerivedParameters = (entry) => {
            // SICHERE NUMERISCHE KONVERTIERUNG DER EINGANGSDATEN
            const speed = safeParseFloat(entry.speed);
            const density = safeParseFloat(entry.density);
            const bx = safeParseFloat(entry.bx_nt);
            const by = safeParseFloat(entry.by_nt);
            const bz = safeParseFloat(entry.bz_nt);
            const timeTag = entry.time_tag;

            // 1. Berechnung des Magnetischen Totalwerts (Bt)
            let totalBt = 'N/A';
            if (!isNaN(bx) && !isNaN(by) && !isNaN(bz)) {
                totalBt = Math.sqrt(bx*bx + by*by + bz*bz);
            } else {
                 const btRaw = safeParseFloat(entry.bt_nt);
                 if (!isNaN(btRaw)) {
                     totalBt = btRaw;
                 }
            }
            
            // 2. Berechnung des Dynamischen Drucks (nPa)
            let dynamicPressure = 'N/A';
            if (!isNaN(speed) && speed > 0 && !isNaN(density) && density >= 0) {
                dynamicPressure = DYNAMIC_PRESSURE_FACTOR * density * (speed * speed);
            }
            
            // 3. Berechnung des Substorm Coupling Index (SCI) (auch bekannt als V * Bs)
            let sci = 'N/A';
            if (!isNaN(speed) && speed > 0 && !isNaN(bz)) {
                // SCI (V_sw * B_s): Geschw. * Southward IMF (nur wenn Bz < 0)
                sci = speed * Math.max(0, -bz);
            }

            // 4. Berechnung des Prognostizierten AL-Potenzials (nT)
            // HINWEIS: AL ist der Betrag des erwarteten negativen Stroms. Hier zeigen wir den Betrag.
            let estimatedALPotential = 'N/A';
            if (typeof sci === 'number' && !isNaN(sci) && sci >= 0) {
                 estimatedALPotential = sci * AL_SCALING_FACTOR;
            }

            // 5. Qualitative Risikobewertung
            const sciRiskLevel = getSciRiskLevel(sci);

            // 6. Kritische Aufbauzeit 
            const criticalBuildupDuration = getRequiredBuildupDuration(sci);
            
            // 7. Berechnung der Ankunftszeit
            let travelTimeHours = 'N/A';
            let travelTimeMinutes = 'N/A';
            let travelTimeMs = null;
            let arrivalDate = 'Ung√ºltige Geschw.';
            let estimatedOnset = 'N/A';

            if (!isNaN(speed) && speed > 0 && speed <= 10000) {
                const travelTimeSeconds = L1_DISTANCE_KM / speed;
                travelTimeHours = travelTimeSeconds / 3600;
                travelTimeMinutes = travelTimeSeconds / 60;
                travelTimeMs = travelTimeSeconds * MS_PER_SEC;
                const measurementDate = parseUtcTimeTag(timeTag);
                arrivalDate = new Date(measurementDate.getTime() + travelTimeMs);
            }
            
            // 8. Gesch√§tzte Sturmbeginn-Zeit
            if (arrivalDate instanceof Date && !isNaN(arrivalDate) && criticalBuildupDuration !== SCI_DURATION_LOW_H) {
                const durationMs = criticalBuildupDuration * 60 * 60 * 1000;
                estimatedOnset = new Date(arrivalDate.getTime() + durationMs);
            }

            // R√ºckgabe des Eintrags mit den √ºberschriebenen numerischen Werten (oder 'N/A')
            return {
                time_tag: timeTag,
                speed: isNaN(speed) ? 'N/A' : speed,
                density: isNaN(density) ? 'N/A' : density,
                bz_nt: isNaN(bz) ? 'N/A' : bz,
                bx_nt: isNaN(bx) ? 'N/A' : bx,
                by_nt: isNaN(by) ? 'N/A' : by,
                total_bt: typeof totalBt === 'number' ? totalBt : 'N/A',
                
                dynamic_pressure_npa: typeof dynamicPressure === 'number' ? dynamicPressure : 'N/A',
                substorm_coupling_index: typeof sci === 'number' ? sci : 'N/A', 
                estimated_al_potential: typeof estimatedALPotential === 'number' ? estimatedALPotential : 'N/A', 
                sci_risk_level: sciRiskLevel, 
                critical_buildup_duration_h: criticalBuildupDuration, 
                travel_time_h: travelTimeHours,
                travel_time_m: travelTimeMinutes, 
                travel_time_ms: travelTimeMs,
                arrival_time: arrivalDate,
                estimated_onset_time: estimatedOnset, 
            };
        };

        // =========================================================================
        // === Diagramm-Logik (Unver√§ndert) ===
        // =========================================================================

        /**
         * Erstellt die Chart.js-Instanz initial.
         */
        const createChart = () => {
             if (typeof Chart === 'undefined') {
                console.error("Chart.js ist nicht definiert. Kann das Diagramm nicht erstellen.");
                return;
            }
            
            const ctx = document.getElementById('solarWindChart').getContext('2d');
            
            const commonOptions = {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    color: '#c9d1d9', 
                    plugins: {
                        legend: {
                            labels: { color: '#c9d1d9' }
                        },
                        title: {
                            display: true,
                            text: 'Solarwind-Parameter (L1) √ºber die Zeit',
                            color: '#58a6ff',
                            font: { size: 18, weight: 'bold' }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x',
                            },
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                drag: { enabled: true },
                                mode: 'x',
                            },
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                tooltipFormat: 'HH:mm:ss',
                                displayFormats: {
                                    minute: 'HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Messzeitpunkt (UTC)',
                                color: '#c9d1d9'
                            },
                            ticks: { color: '#c9d1d9' },
                            grid: { color: 'rgba(48, 54, 61, 0.5)' }
                        },
                        yPlasma: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Plasma (Geschw. km/s | Dichte p/cm¬≥)',
                                color: '#ff7b72' 
                            },
                            ticks: { color: '#ff7b72' },
                            grid: { color: 'rgba(48, 54, 61, 0.5)' }
                        },
                        yMag: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Magnetfeld (nT)',
                                color: '#79c0ff' 
                            },
                            ticks: { color: '#79c0ff' },
                            grid: { drawOnChartArea: false } // Nur Gitterlinien von yPlasma anzeigen
                        }
                    }
                }
            };

            chartInstance = new Chart(ctx, commonOptions);
        };

        /**
         * Aktualisiert die Chart-Daten mit chronologisch sortierten Eintr√§gen.
         */
        const updateChart = (data) => {
            if (!chartInstance) return;

            // X-Achse: Zeitpunkte als Labels (Date.parse f√ºr Chart.js time scale)
            const labels = data.map(d => parseUtcTimeTag(d.time_tag).getTime());

            // Datasets
            const datasets = [
                // Geschwindigkeit (Speed)
                {
                    label: 'Geschw. (km/s)',
                    // Verwende den nummerischen Wert, filtere "N/A" (NaN)
                    data: data.map(d => typeof d.speed === 'number' ? d.speed : NaN), 
                    borderColor: '#ff7b72', // Rot-Ton
                    backgroundColor: 'rgba(255, 123, 114, 0.2)',
                    yAxisID: 'yPlasma',
                    tension: 0.2,
                    pointRadius: 1
                },
                // Dichte (Density)
                {
                    label: 'Dichte (p/cm¬≥)',
                    data: data.map(d => typeof d.density === 'number' ? d.density : NaN),
                    borderColor: '#f97316', // Orange-Ton
                    backgroundColor: 'rgba(249, 115, 22, 0.2)',
                    yAxisID: 'yPlasma',
                    tension: 0.2,
                    pointRadius: 1
                },
                // Total Bt
                {
                    label: 'Total Bt (nT)',
                    data: data.map(d => typeof d.total_bt === 'number' ? d.total_bt : NaN),
                    borderColor: '#79c0ff', // Blau-Ton
                    backgroundColor: 'rgba(121, 192, 255, 0.2)',
                    yAxisID: 'yMag',
                    tension: 0.2,
                    pointRadius: 1
                },
                // Bz
                {
                    label: 'Bz (nT)',
                    data: data.map(d => typeof d.bz_nt === 'number' ? d.bz_nt : NaN),
                    borderColor: '#e83966', // Magenta-Ton (f√ºr kritischen Bz)
                    backgroundColor: 'rgba(232, 57, 102, 0.2)',
                    yAxisID: 'yMag',
                    tension: 0.2,
                    pointRadius: 2, 
                }
            ];

            // Datenformat f√ºr Chart.js (Array von Objekten {x: timestamp, y: value})
            chartInstance.data.datasets = datasets.map(dataset => ({
                ...dataset,
                data: dataset.data.map((y, index) => ({ x: labels[index], y: y }))
            }));

            // Aktualisiere das Diagramm
            chartInstance.update();
        };

        // =========================================================================
        // === Statuskarten-Logik (Erweitert) ===
        // =========================================================================

        /**
         * Aktualisiert die Statuskarte √ºber der Tabelle mit den aktuellsten Werten.
         */
        const updateStatusCard = (entry) => {
            const nowUtc = new Date();
            
            // 1. Messzeitpunkt
            latestTimeTagEl.textContent = entry.time_tag.substring(11, 16) + ' UTC';

            // 2. Ankunftszeit
            let arrivalText = 'Wird berechnet...';
            let arrivalColor = 'text-gray-300';
            
            if (entry.arrival_time instanceof Date && !isNaN(entry.arrival_time)) {
                const diffMs = entry.arrival_time.getTime() - nowUtc.getTime();
                const arrivalTimeStr = entry.arrival_time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', timeZone: 'UTC' });
                
                if (diffMs <= 0) {
                    arrivalText = `ANGEKOMMEN! ${arrivalTimeStr} UTC`;
                    arrivalColor = 'text-green-500';
                } else if (diffMs <= THIRTY_MINUTES_MS) {
                    arrivalText = `üîú ${arrivalTimeStr} UTC (Bald!)`;
                    arrivalColor = 'text-red-400';
                } else {
                    arrivalText = `${arrivalTimeStr} UTC (${entry.travel_time_h.toFixed(1)} h)`;
                    arrivalColor = 'text-blue-400';
                }
            }
            arrivalTimeStatusEl.textContent = arrivalText;
            arrivalTimeStatusEl.className = `metric-value ${arrivalColor}`;

            // 3. Bz-Komponente
            const bz = entry.bz_nt; // Ist jetzt Nummer oder 'N/A'
            let bzText = 'N/A';
            let bzColor = 'text-gray-300';
            
            if (typeof bz === 'number') {
                bzText = `${bz.toFixed(1)} nT`;
                if (bz < -5) { 
                    bzColor = 'text-red-400 font-extrabold';
                    bzText = `‚¨áÔ∏è S√úD ${bzText}`;
                } else if (bz < 0) {
                    bzColor = 'text-orange-300';
                    bzText = `‚Üì S√ºd ${bzText}`;
                } else if (bz > 5) {
                    bzColor = 'text-blue-300';
                    bzText = `‚¨ÜÔ∏è Nord ${bzText}`;
                } else if (bz > 0) {
                    bzColor = 'text-green-400';
                    bzText = `‚Üë Nord ${bzText}`;
                }
            }
            bzStatusEl.textContent = bzText;
            bzStatusEl.className = `metric-value ${bzColor}`;

            // 4. AL-Potenzial (NEU: Prog. AL-Index)
            const alPotential = entry.estimated_al_potential;
            let alText = 'N/A';
            let alColor = 'text-gray-300';

            if (typeof alPotential === 'number') {
                alText = `${alPotential.toFixed(0)} nT`;
                 if (alPotential >= AL_SEVERE_THRESHOLD) {
                    alColor = 'text-red-600 font-extrabold';
                } else if (alPotential >= AL_STRONG_THRESHOLD) {
                    alColor = 'text-red-400 font-extrabold';
                } else if (alPotential >= AL_MODERATE_THRESHOLD) {
                    alColor = 'text-orange-400 font-bold';
                } else if (alPotential > 50) {
                    alColor = 'text-yellow-400';
                }
            }
            alPotentialStatusEl.textContent = alText;
            alPotentialStatusEl.className = `metric-value ${alColor}`;
        };


        // =========================================================================
        // === Tabellen- und UI-Logik (Erweitert) ===
        // =========================================================================
        
        // Hilfsfunktion zum sicheren Formatieren von Zahlen (vermeidet toFixed auf 'N/A'/'null')
        const safeFormat = (value, precision = 1) => {
            return typeof value === 'number' ? value.toFixed(precision) : String(value);
        };


        /**
         * Rendert die Daten in die HTML-Tabelle
         */
        const renderTable = (data) => {
            tableBody.innerHTML = '';
            if (data.length === 0) {
                statusMessage.textContent = 'Keine Daten in den letzten 2 Stunden zum Anzeigen vorhanden.';
                statusMessage.classList.remove('hidden', 'bg-red-900', 'bg-green-900/50');
                statusMessage.classList.add('bg-yellow-900', 'text-yellow-400');
                plasmaTable.classList.add('hidden');
                return;
            }
            
            const nowUtc = new Date();

            data.forEach((entry, index) => {
                
                let isArrived = false;
                if (entry.arrival_time instanceof Date && !isNaN(entry.arrival_time)) {
                    if (entry.arrival_time.getTime() <= nowUtc.getTime()) {
                        isArrived = true;
                    }
                }

                let rowClass = index % 2 !== 0 ? 'bg-gray-700/50' : '';
                rowClass += isArrived ? ' highlight-row' : '';

                const row = document.createElement('tr');
                row.className = `border-b border-gray-700 hover:bg-gray-700 transition duration-150 ${rowClass}`;

                // --- Bz (Magnetfeld) Verbesserungen ---
                let bzColor = 'text-gray-300';
                let bzIcon = '';
                const bz = entry.bz_nt; // IST JETZT ZAHL ODER 'N/A'
                if (typeof bz === 'number') {
                    if (bz < -5) { 
                        bzColor = 'text-red-400 font-bold';
                        bzIcon = '‚¨áÔ∏è'; 
                    } else if (bz < 0) {
                        bzColor = 'text-orange-300';
                        bzIcon = '‚Üì'; 
                    } else if (bz > 5) {
                        bzColor = 'text-blue-300';
                        bzIcon = '‚¨ÜÔ∏è'; 
                    } else if (bz > 0) {
                        bzColor = 'text-green-400';
                        bzIcon = '‚Üë'; 
                    }
                }

                // Farben f√ºr die Geschwindigkeit
                let speedColor = 'text-green-400';
                const speed = entry.speed; // IST JETZT ZAHL ODER 'N/A'
                if (typeof speed === 'number') {
                    if (speed > 550) {
                        speedColor = 'text-red-400 font-bold';
                    } else if (speed > 450) {
                        speedColor = 'text-yellow-400';
                    }
                }

                // --- Dyn. Druck Hervorhebung und Kompression ---
                let pressureColor = 'text-gray-300';
                let compressionIcon = '';
                const pressure = entry.dynamic_pressure_npa;
                const density = entry.density; // IST JETZT ZAHL ODER 'N/A'

                if (typeof pressure === 'number') {
                    if (pressure > CRITICAL_PRESSURE_NPA) {
                        pressureColor = 'text-red-400 font-bold'; 
                    } else if (pressure > 5.0) {
                        pressureColor = 'text-orange-400'; 
                    } else if (pressure < 0.5) {
                        pressureColor = 'text-gray-500'; 
                    }
                }

                // Kompressions-Indikator
                if (typeof density === 'number' && density >= CRITICAL_DENSITY && typeof pressure === 'number' && pressure > 5.0) {
                    pressureColor = 'text-yellow-300 font-extrabold'; 
                    compressionIcon = 'üí• STAU!'; 
                }

                // --- Total Bt Hervorhebung ---
                let btColor = 'text-gray-300';
                const totalBt = entry.total_bt;
                if (typeof totalBt === 'number' && totalBt > CRITICAL_BT) {
                    btColor = 'text-yellow-300 font-bold';
                } else if (typeof totalBt === 'number' && totalBt < 5.0) {
                    btColor = 'text-gray-500';
                }

                // --- SCI und AL-Potenzial ---
                const sci = entry.substorm_coupling_index;
                const alPotential = entry.estimated_al_potential;
                let sciColor = 'text-gray-300';
                let alColor = 'text-gray-300';

                if (typeof sci === 'number') {
                    if (sci > SCI_WATCH_HIGH) {
                        sciColor = 'text-red-400 font-extrabold';
                        row.classList.add('substorm-watch-high'); 
                    } else if (sci > SCI_WATCH_ELEVATED) {
                        sciColor = 'text-orange-400 font-bold';
                        row.classList.add('substorm-watch-elevated');
                    } else if (sci > SCI_WATCH_LOW) {
                        sciColor = 'text-yellow-400';
                    }
                }
                
                if (typeof alPotential === 'number') {
                    if (alPotential >= AL_SEVERE_THRESHOLD) {
                        alColor = 'text-red-600 font-extrabold';
                    } else if (alPotential >= AL_STRONG_THRESHOLD) {
                        alColor = 'text-red-400 font-extrabold';
                    } else if (alPotential >= AL_MODERATE_THRESHOLD) {
                        alColor = 'text-orange-400 font-bold';
                    } else if (alPotential > 50) {
                        alColor = 'text-yellow-400';
                    }
                }
                
                const sciValue = safeFormat(sci, 0);
                const alValue = safeFormat(alPotential, 0);
                
                row.innerHTML += `<td class="py-3 px-6 text-left">${formatTime(parseUtcTimeTag(entry.time_tag))}</td>`;
                // SICHERE ANZEIGE: Nutze safeFormat f√ºr alle Zahlenspalten
                row.innerHTML += `<td class="py-3 px-6 text-left ${speedColor}">${safeFormat(entry.speed, 1)}</td>`;
                row.innerHTML += `<td class="py-3 px-6 text-left">${safeFormat(entry.density, 2)}</td>`;
                
                // Dynamischer Druck Zelle
                row.innerHTML += `<td class="py-3 px-6 text-left ${pressureColor}">
                    ${compressionIcon ? `<span class="mr-1">${compressionIcon}</span>` : ''}${safeFormat(pressure, 2)}
                </td>`;
                
                // Total Bt Zelle
                row.innerHTML += `<td class="py-3 px-6 text-left ${btColor}">${safeFormat(totalBt, 1)}</td>`;
                
                // Bz (nT)
                row.innerHTML += `<td class="py-3 px-6 text-left ${bzColor}">
                    ${bzIcon ? `<span class="mr-1">${bzIcon}</span>` : ''}${safeFormat(bz, 1)}
                </td>`;

                // Prognostizierter AL-Index (AKTUALISIERT)
                row.innerHTML += `<td class="py-3 px-6 text-left ${alColor}">
                    ${alValue}
                </td>`;

                // SCI (Substorm Coupling Index) Zelle
                 row.innerHTML += `<td class="py-3 px-6 text-left ${sciColor}">
                    ${sciValue}
                </td>`;
                
                // Gesch√§tzte Sturmbeginn-Zeit
                let onsetTimeText = 'N/A';
                let onsetTimeColor = 'text-gray-400';
                
                if (entry.estimated_onset_time instanceof Date && !isNaN(entry.estimated_onset_time)) {
                    onsetTimeText = formatTime(entry.estimated_onset_time).substring(11, 20); 
                    const diffMs = entry.estimated_onset_time.getTime() - nowUtc.getTime();

                    if (diffMs > 0 && diffMs <= THIRTY_MINUTES_MS) {
                        onsetTimeColor = 'text-red-300 font-bold';
                        onsetTimeText = `‚ö†Ô∏è SOON! ${onsetTimeText}`;
                    } else if (diffMs <= 0) {
                        onsetTimeColor = 'text-red-400 font-extrabold';
                        onsetTimeText = `‚ö†Ô∏è JETZT! ${onsetTimeText}`;
                    } else {
                        onsetTimeColor = 'text-blue-300';
                    }
                }
                
                row.innerHTML += `<td class="py-3 px-6 text-left ${onsetTimeColor}">${onsetTimeText}</td>`;

                // Substurm-Risiko Zelle
                let riskColor = '';
                if (entry.sci_risk_level.startsWith('üö® HOCH')) {
                    riskColor = 'text-red-400 font-bold';
                } else if (entry.sci_risk_level.startsWith('‚ö†Ô∏è Erh√∂ht')) {
                    riskColor = 'text-orange-400';
                } else if (entry.sci_risk_level.startsWith('Mittel')) {
                    riskColor = 'text-yellow-400';
                } else {
                    riskColor = 'text-gray-400';
                }

                row.innerHTML += `<td class="py-3 px-6 text-left ${riskColor}">
                    ${entry.sci_risk_level}
                </td>`;


                // --- √úberhol-Indikator ---
                let isOvertaking = false;
                if (index < data.length - 1) {
                    const nextEntry = data[index + 1]; 
                    const currentArrival = entry.arrival_time instanceof Date ? entry.arrival_time.getTime() : Infinity;
                    const nextArrival = nextEntry.arrival_time instanceof Date ? nextEntry.arrival_time.getTime() : Infinity;

                    if (currentArrival < nextArrival) {
                        isOvertaking = true;
                    }
                }
                
                // Ankunftszeit
                let arrivalTimeCell = `<td class="py-3 px-6 text-left">`;
                
                if (entry.arrival_time instanceof Date && !isNaN(entry.arrival_time)) {
                    const diffMs = entry.arrival_time.getTime() - nowUtc.getTime();
                    
                    let timeText = entry.arrival_time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: 'UTC' }) + ' UTC';
                    let cellClass = '';

                    if (isOvertaking) {
                        cellClass += ' bg-pink-900/40 border-l border-pink-600';
                        timeText = `<span class="text-pink-400 font-extrabold">üèéÔ∏è √úBERHOLT! ${timeText}</span>`;
                    }
                    
                    else if (diffMs > 0 && diffMs <= THIRTY_MINUTES_MS) {
                        cellClass = 'bg-blue-900/40 border-r border-blue-600';
                        timeText = `<span class="text-blue-300 font-extrabold">üîú ${timeText}</span>`;
                    } 
                    
                    else if (isArrived) {
                        timeText = `<span class="font-bold text-gray-200">${timeText}</span>`;
                    } 
                    
                    else {
                        timeText = `<span class="font-medium">${timeText}</span>`;
                    }

                    arrivalTimeCell = `<td class="py-3 px-6 text-left ${cellClass}">`;
                    arrivalTimeCell += timeText;
                    
                } else {
                    arrivalTimeCell += `<span class="text-red-500">${entry.arrival_time}</span>`;
                }
                arrivalTimeCell += `</td>`;
                row.innerHTML += arrivalTimeCell;
                
                tableBody.appendChild(row);
            });
            plasmaTable.classList.remove('hidden');
        };

        /**
         * Sortiert die Daten basierend auf der ausgew√§hlten Spalte und Richtung
         */
        const sortData = () => {
            const keyMap = {
                'time_tag': d => parseUtcTimeTag(d.time_tag).getTime(),
                'speed': d => typeof d.speed === 'number' ? d.speed : -Infinity,
                'density': d => typeof d.density === 'number' ? d.density : -Infinity,
                'dynamic_pressure_npa': d => typeof d.dynamic_pressure_npa === 'number' ? d.dynamic_pressure_npa : -Infinity,
                'total_bt': d => typeof d.total_bt === 'number' ? d.total_bt : -Infinity,
                'bz_nt': d => typeof d.bz_nt === 'number' ? d.bz_nt : -Infinity,
                'estimated_al_potential': d => typeof d.estimated_al_potential === 'number' ? d.estimated_al_potential : -Infinity,
                'substorm_coupling_index': d => typeof d.substorm_coupling_index === 'number' ? d.substorm_coupling_index : -Infinity,
                'estimated_onset_time': d => d.estimated_onset_time instanceof Date ? d.estimated_onset_time.getTime() : Infinity,
                'sci_risk_level': d => typeof d.substorm_coupling_index === 'number' ? d.substorm_coupling_index : -Infinity, 
                'arrival_time': d => d.travel_time_ms !== null ? parseUtcTimeTag(d.time_tag).getTime() + d.travel_time_ms : -Infinity,
            };

            allData.sort((a, b) => {
                const valA = keyMap[sortColumn](a);
                const valB = keyMap[sortColumn](b);

                let comparison = 0;
                if (valA > valB) {
                    comparison = 1;
                } else if (valA < valB) {
                    comparison = -1;
                }

                // Standardm√§√üig ASC, au√üer bei Zeitstempel
                let finalComparison = comparison;
                if (sortDirection === 'desc' && sortColumn !== 'time_tag') {
                     finalComparison = comparison * -1;
                }
                
                // Spezielle Logik f√ºr kritische Spalten (bz, AL, SCI): Immer DESC (h√∂chste Aktivit√§t zuerst)
                if (sortColumn === 'bz_nt') {
                    // Bz: Gr√∂√üere NEGATIVE Zahl ist kritischer. Daher ASC (d.h. -10 kommt vor -5)
                    finalComparison = comparison; 
                }
                if (sortColumn === 'estimated_al_potential' || sortColumn === 'substorm_coupling_index') {
                    // AL-Potenzial/SCI: Gr√∂√üere positive Zahl ist kritischer. Daher DESC (hoch zuerst)
                    finalComparison = comparison * -1;
                }
                // F√ºr time_tag ist DESC der Standard (neueste zuerst)
                if (sortColumn === 'time_tag') {
                    finalComparison = comparison * -1;
                }


                return finalComparison;
            });

            document.querySelectorAll('[data-sort-icon]').forEach(icon => icon.textContent = '');
            const currentIcon = document.querySelector(`[data-sort-icon="${sortColumn}"]`);
            if (currentIcon) {
                currentIcon.textContent = sortDirection === 'asc' ? '‚Üë' : '‚Üì';
                // Bz und AL/SCI haben eine feste visuelle Sortierrichtung
                if (sortColumn === 'bz_nt' || sortColumn === 'estimated_al_potential' || sortColumn === 'substorm_coupling_index') {
                    currentIcon.textContent = '‚Üì';
                }
                // Zeit ist immer DESC (neueste zuerst)
                 if (sortColumn === 'time_tag') {
                    currentIcon.textContent = '‚Üì';
                }
            }
            
            // Standardm√§√üig nach Zeit absteigend sortieren, wenn die Seite das erste Mal l√§dt
            if (sortColumn === 'time_tag') {
                const defaultIcon = document.querySelector(`[data-sort-icon="time_tag"]`);
                defaultIcon.textContent = '‚Üì';
            }


            renderTable(allData);
        };

        /**
         * Holt die Daten von einem NOAA-Endpunkt
         */
        const fetchData = async (url) => {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP-Fehler beim Laden von ${url}: ${response.status}`);
            }
            const rawData = await response.json();
            // Die erste Zeile enth√§lt Header, daher .slice(1)
            return rawData.slice(1);
        };


        /**
         * Hauptfunktion zum Abrufen und Verarbeiten der Daten
         */
        const fetchSolarWindData = async () => {
            loadingIndicator.classList.remove('hidden');
            statusMessage.classList.add('hidden');
            plasmaTable.classList.add('hidden');

            try {
                
                const [plasmaDataRaw, magDataRaw] = await Promise.all([
                    fetchData(PLASMA_API_URL),
                    fetchData(MAG_API_URL)
                ]);

                // Indizes f√ºr das Magnetfeld-Array:
                const MAG_TIME_INDEX = 0;
                const MAG_BX_INDEX = 1;
                const MAG_BY_INDEX = 2;
                const MAG_BZ_INDEX = 3;
                const MAG_BT_INDEX = 4;

                const magMap = new Map();
                magDataRaw.forEach(row => {
                    const timeTag = row[MAG_TIME_INDEX];
                    magMap.set(timeTag, {
                        bx_nt: row[MAG_BX_INDEX] || 'N/A',
                        by_nt: row[MAG_BY_INDEX] || 'N/A',
                        bz_nt: row[MAG_BZ_INDEX] || 'N/A',
                        bt_nt: row[MAG_BT_INDEX] || 'N/A'
                    });
                });

                const processedData = plasmaDataRaw.map(row => {
                    const timeTag = row[0];
                    const magEntry = magMap.get(timeTag) || { bx_nt: 'N/A', by_nt: 'N/A', bz_nt: 'N/A', bt_nt: 'N/A' };
                    
                    const entry = {
                        time_tag: timeTag,
                        // Plasma Data Indices: 1=Density, 2=Speed
                        density: row[1] || 'N/A',
                        speed: row[2] || 'N/A',
                        bx_nt: magEntry.bx_nt, 
                        by_nt: magEntry.by_nt,
                        bz_nt: magEntry.bz_nt,
                        bt_nt: magEntry.bt_nt,
                    };
                    return calculateDerivedParameters(entry); 
                });

                if (processedData.length > 0) {
                    
                    // Finde den neuesten Eintrag zur Anzeige im Status-Dashboard
                    const sortedByTimeDesc = [...processedData].sort((a, b) => 
                        parseUtcTimeTag(b.time_tag).getTime() - parseUtcTimeTag(a.time_tag).getTime()
                    );
                    const latestEntry = sortedByTimeDesc[0];
                    updateStatusCard(latestEntry);

                    const latestTimeMs = parseUtcTimeTag(latestEntry.time_tag).getTime();
                    const cutoffTimeMs = latestTimeMs - TWO_HOURS_MS;

                    // Filterung auf die letzten 2 Stunden
                    allData = processedData.filter(entry => {
                        const entryTimeMs = parseUtcTimeTag(entry.time_tag).getTime();
                        return entryTimeMs >= cutoffTimeMs;
                    });
                    
                    // √úberpr√ºfung, ob nach Filterung noch Daten vorhanden sind
                     if (allData.length === 0) {
                        throw new Error('Keine Daten in den letzten 2 Stunden gefunden.');
                    }
                    
                    // --- LOGIK F√úR DAS DIAGRAMM ---
                    const chartData = [...allData].sort((a, b) => 
                        parseUtcTimeTag(a.time_tag).getTime() - parseUtcTimeTag(b.time_tag).getTime()
                    );
                    updateChart(chartData);


                    statusMessage.textContent = `Daten (24h Quellen) erfolgreich geladen. Zeige ${allData.length} Eintr√§ge der letzten 2 Stunden (bis zum letzten Messwert, UTC). N√§chste Aktualisierung in 1 Minute.`;
                    statusMessage.classList.remove('hidden', 'bg-red-900', 'bg-yellow-900');
                    statusMessage.classList.add('bg-green-900/50', 'text-green-400', 'font-semibold');

                } else {
                    allData = [];
                    throw new Error('Es wurden keine g√ºltigen Daten vom Server empfangen.');
                }

                sortData(); // Stellt die Anzeige nach dem Laden sicher

            } catch (error) {
                console.error("Fehler beim Abrufen/Verarbeiten der Daten:", error);
                statusMessage.textContent = `Fehler beim Laden oder Verarbeiten der Daten: ${error.message}. N√§chste Aktualisierung in 1 Minute.`;
                statusMessage.classList.remove('hidden', 'bg-green-900/50', 'bg-yellow-900');
                statusMessage.classList.add('bg-red-900', 'text-red-400');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        };

        /**
         * Startet den initialen Ladevorgang und richtet den Auto-Refresh-Intervall ein.
         */
        const startApp = () => {
            if (typeof Chart !== 'undefined' && typeof ChartZoom !== 'undefined') {
                Chart.register(ChartZoom);
            }
            
            createChart(); 

            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.sortKey;
                    if (sortColumn === key) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = key;
                        // Standard Sortierrichtung basierend auf Kritikalit√§t
                        if (key === 'bz_nt' || key === 'estimated_al_potential' || key === 'substorm_coupling_index') {
                            sortDirection = 'desc'; // Kritische Werte (negativ/hoch) zuerst
                        } else if (key === 'estimated_onset_time') {
                             sortDirection = 'asc'; // Fr√ºhester Zeitpunkt zuerst
                        } else {
                            sortDirection = 'desc'; 
                        }
                    }
                    sortData();
                });
            });

            fetchSolarWindData();
            setInterval(fetchSolarWindData, REFRESH_INTERVAL_MS);
        };

        window.onload = startApp;
    </script>
</body>
</html>
